var mod = angular.module('app.productApp',[]);
var mod = angular.module('app.saleApp',[]);
var mod = angular.module('model.group',[]);


var mod = angular.module('model.mix_match',[]);
var mod = angular.module('model.non_inventory',[]);

angular.module('model.product',[]);
var mod = angular.module('model.receipt',[])
var mod = angular.module('model.report',[]);
var mod = angular.module('model.store',[]);
angular.module('model.store_product',[]);
var mod = angular.module('share.menu',[])
var mod = angular.module('share.ui',[]);
var mod = angular.module('share.util',[]);

var mod = angular.module('share.offline_db_util',[]);
mod.factory('share.offline_db_util',
[
    '$q',
    '$rootScope',
    'share_setting',
    'blockUI',
function(
    $q,
    $rootScope,
    share_setting,
    blockUI 
){
    function get(){
       var db_name = share_setting.STORE_DB_PREFIX + share_setting.STORE_ID;
       return new PouchDB(db_name);           
    }
    function remove_doc(doc_id){
        var defer = $q.defer();

        var db = get();
        db.get(doc_id).then(
             function(doc) { 
                db.remove(doc).then(
                    function(response){ 
                        defer.resolve(response); 
                    }
                    ,function(reason){ 
                        defer.reject(reason); 
                    }
                )
            }
            ,function(reason){ defer.reject(reason); }
        );              
        
        return defer.promise;
    }
    function is_exist(){
        var defer = $q.defer();
        var db_name = '_pouch_' + share_setting.STORE_DB_PREFIX + share_setting.STORE_ID;
        var request = indexedDB.open(db_name);

        request.onupgradeneeded = function (e){
            e.target.transaction.abort();
            // defer.resolve(false);
        }
        request.onsuccess = function(e) {
            defer.resolve(true);
        }
        request.onerror = function(e) {
            if(e.target.error.name == "AbortError"){
                indexedDB.deleteDatabase(db_name);
                defer.resolve(false);
            }else{
                defer.reject('error when checking db existance');
            }
        }   
        return defer.promise;
    }  

    function download_product(is_create_if_local_db_not_exist){
        /*
            return {
                local: the_number_of_local_doc
                remote: the_number_of_remote_doc
                docs_written : pouch_response_docs_written
            }
        */
        var defer = $q.defer();

        if(is_create_if_local_db_not_exist){
            _force_download_product().then(
                function(response){
                    defer.resolve(response);
                },function(reason){
                    defer.reject(reason);
                }
            )
        }else{
            is_exist().then(
                function(is_db_exist){
                    if(is_db_exist){
                        _force_download_product().then(
                            function(response){
                                defer.resolve(response);
                            },function(reason){
                                defer.reject(reason);
                            }
                        )
                    }else{
                        defer.resolve(null);
                    }
                },
                function(reason){
                    return defer.reject(reason);
                }
            )
        }
        return defer.promise;
    } 

    function _force_download_product(){
        var defer = $q.defer();

        var store_id = 18;
        var db_name = 'liquor_' + store_id;
        var local_db = new PouchDB(db_name);
        var couch_server_url = 'https://' + 'ffireventaiduretrimarril' + ':' + 'O7bnrIIMumwfueNuMat6SnaA' + '@' + 'khanhlu2013ceci.cloudant.com'
        var source_url = couch_server_url + '/' + db_name;

        // var store_id = share_setting.STORE_ID;
        // var db_name = share_setting.STORE_DB_PREFIX + store_id;
        // var local_db = new PouchDB(db_name);
        // var source_url = share_setting.COUCH_SERVER_URL + '/' + db_name;

        blockUI.start('syncing database ...');
        console.log('begin syncing for store_id: ' + store_id);

        PouchDB.replicate(source_url, local_db/*target*/, {batch_size:200 ,batches_limit:10 })
            .on('change', function (info) {
                $rootScope.$apply(function()  {
                    // var message = 'docs_read: ' + info.docs_read + ', docs_written: ' + info.docs_written + ', doc_write_failures: ' + info.doc_write_failures;
                    var message = info.docs_written + ' products synced';
                    blockUI.message(message);
                });                            
            })
            .on('complete', function (info) {              
                defer.resolve(info);
                blockUI.stop();   
            })
            .on('error', function (err) {
                $rootScope.$apply(function()  {
                    var message = 'there is sync error: ' + err;
                    defer.reject(message);
                    blockUI.stop();
                });                     
            });
        return defer.promise;
    }           

    function get_pouch_view_name(view_name){
        /*
            since couch build all views that are group into one doc (when any of them is query), i 
            want to have each view resign in separate doc so that i can fully LAZY building the view 
            to spread out the work load for smoother user experience. 

            Now, we have multiple doc that each have a separate id and contain 1 view. I also have 
            a convention to name the doc_id as _design/view_name so that the doc id can be calculated
            from the view name. This helper function construct the view name that understood by pouchdb
        */
        return view_name + '/' + view_name;
    }

    return{
        get:get,
        remove_doc : remove_doc,
        is_exist : is_exist,
        download_product : download_product,
        get_pouch_view_name : get_pouch_view_name
    }
}]);











var mod = angular.module('app.construct_app_setting',[
    'model.mix_match',
    'model.store'
]);
mod.factory('app.construct_app_setting',
[
    'model.mix_match.Mix_match',
    'model.store.Store',    
function(
    Mix_match,
    Store
){
    return function(share_setting){
        /*
            . there are 2 way to get global setting
                . in django html template. in this case, django auto convert json string into json - i believe with the | safe option
                . through ajax. In this case, the response data.data is an object with setting property is of type string(unlike django template)

            . due to the mixmatch mention above, this set service will convert share_setting(which can be get though template or ajax) property into json if it is string
        */
        //django template auto convert json string into json. but when we ajax to get setting, the response data.data is an object with value to key is of type string. so we need to parse here

        if(typeof(share_setting.STORE) === 'string'){
            share_setting.STORE = JSON.parse(share_setting.STORE)
        }            
        if(typeof(share_setting.MIX_MATCH_LST) === 'string'){
            share_setting.MIX_MATCH_LST = JSON.parse(share_setting.MIX_MATCH_LST)
        }
        if(typeof(share_setting.PAYMENT_TYPE_LST) === 'string'){
            share_setting.PAYMENT_TYPE_LST = JSON.parse(share_setting.PAYMENT_TYPE_LST)
        }
        if(typeof(share_setting.SHORTCUT_LST) === 'string'){
            share_setting.SHORTCUT_LST = JSON.parse(share_setting.SHORTCUT_LST)
        }                      

        var result = 
        {
            STORE:                         Store.build(share_setting.STORE),
            STORE_ID :                     share_setting.STORE_ID,
            TAX_RATE :                     share_setting.TAX_RATE,
            COUCH_SERVER_URL:              share_setting.COUCH_SERVER_URL,       
            STORE_DB_PREFIX:               share_setting.STORE_DB_PREFIX,
            MIX_MATCH_LST :                share_setting.MIX_MATCH_LST.map(Mix_match.build),
            PAYMENT_TYPE_LST:              share_setting.PAYMENT_TYPE_LST,
            SHORTCUT_LST:                  share_setting.SHORTCUT_LST,
            SHORTCUT_ROW_COUNT:            share_setting.SHORTCUT_ROW_COUNT,
            SHORTCUT_COLUMN_COUNT:         share_setting.SHORTCUT_COLUMN_COUNT,
            STORE_PRODUCT_DOCUMENT_TYPE:   share_setting.STORE_PRODUCT_DOCUMENT_TYPE,
            RECEIPT_DOCUMENT_TYPE:         share_setting.RECEIPT_DOCUMENT_TYPE,
            STATIC_URL:                    share_setting.STATIC_URL,
            MAX_RECEIPT_SNOOZE_1:          30,
            MAX_RECEIPT_SNOOZE_2:          60,
            MAX_RECEIPT:                   200,
            VIEW_BY_PRODUCT_ID:            share_setting.VIEW_BY_PRODUCT_ID,
            VIEW_BY_SKU:                   share_setting.VIEW_BY_SKU,
            VIEW_BY_D_TYPE:                share_setting.VIEW_BY_D_TYPE,
        }        
        return result;
    }
}])
var mod = angular.module('app.productApp');
mod.requires.push.apply(mod.requires,[
    'ui.bootstrap',
    'infinite-scroll',
    'blockUI',    
    'share.util.csrf',
    'share.filter',
    'share.directive',
    'share.menu',
    'app.productApp.partial'
]);

mod.config(['$sceDelegateProvider',function($sceDelegateProvider) {
    $sceDelegateProvider.resourceUrlWhitelist([
        // Allow same origin resource loads.
        'self',
        // 'http://127.0.0.1:8000/*', //i think i need this when i am dealing with partial? (the network product partial)
        // Allow loading from our assets domain.  Notice the difference between * and **.
        // 'https://liquorkhanhlu2013.s3.amazonaws.com/**'
    ]);
}]);

mod.config(['blockUIConfig',function(blockUIConfig) {
    blockUIConfig.message = 'loading ...';
    blockUIConfig.autoBlock = true;
    blockUIConfig.delay = 0;
}]);
var app = angular.module('app.productApp');
app.requires.push.apply(app.requires,[
    'model.store_product',
    'share.ui',
    'share.offline_db_util'
]);
app.controller('app.productApp.controller',
[
    '$scope',
    '$rootScope',
    '$q',
    '$window',
    'model.store_product.rest_search',
    'share.ui.alert',
    'share.ui.confirm',
    'model.store_product.sku_not_found_handler',
    'share.offline_db_util',
    'model.store_product.search.online.infinite_scroll_handler',
function(
    $scope,
    $rootScope,
    $q,
    $window,
    sp_rest_search,
    alert_service,
    confirm_service,
    sku_not_found_handler,
    offline_db_util,
    search_online_infinite_scroll_handler
){
    var un_subscribe_group = $rootScope.$on('model.group.manage',function(event,data){
        _refresh_current_sp_lst();
    })
    $scope.$on('$destroy',un_subscribe_group);

    function launch_pos_url(){
        $window.open('sale/index_angular/');
    }
    $scope.launch_pos = function(){
        offline_db_util.is_exist().then(
             function(db_exitance){
                if(db_exitance){
                    confirm_service('launch sale app?').then(function(){
                        launch_pos_url();
                    });                        
                }else{
                    confirm_service('first time download database. continue?').then(function(){
                        launch_pos_url();
                    });
                }
            }
            ,function(reason){
                alert_service(reason)
            }
        )
    }

    $scope.sku_search = function(){
        $scope.name_search_str = "";
        $scope.local_filter = "";
        $scope.sku_search_str = $scope.sku_search_str.trim().toLowerCase();

        if($scope.sku_search_str.length === 0){
            $scope.sp_lst = [];
            return;
        }
        sp_rest_search.by_sku($scope.sku_search_str).then(
            function(data){
                $scope.sp_lst = data.prod_store__prod_sku__1_1;
                if($scope.sp_lst.length === 0){
                    var promise = sku_not_found_handler(data.prod_store__prod_sku__0_0,data.prod_store__prod_sku__1_0,$scope.sku_search_str).then
                    (
                        function(created_sp){ 
                            $scope.sp_lst = [created_sp];
                        }
                        ,function(reason){
                            alert_service(reason);
                        }
                    );
                } 
            }
            ,function(reason){ 
                alert_service(reason);
            }
        )
    }
    function _refresh_current_sp_lst(){
        $scope.sp_lst = [];        
        $scope.name_search_str = '';
        $scope.sku_search_str = '';             
    }    
    $scope.column_click = function(column_name){
        if($scope.cur_sort_column === column_name){
            $scope.cur_sort_desc = !$scope.cur_sort_desc;
        }else{
            $scope.cur_sort_column = column_name;
            $scope.cur_sort_desc = false;
        }
    }
    $scope.get_sort_class = function(column_name){
        if(column_name === $scope.cur_sort_column){
            return "glyphicon glyphicon-arrow-" + ($scope.cur_sort_desc ? 'down' : 'up');
        }else{
            return '';
        }
    }    

    $scope.name_search = function(){
        //clear out search form
        $scope.sku_search_str = "";
        $scope.local_filter = "";
        $scope.infinite_scroll_reach_the_end = false;
        $scope.name_search_str = $scope.name_search_str.trim();
        $scope.sp_lst = [];

        if($scope.name_search_str.length === 0){
            return;
        }
 
        sp_rest_search.by_name($scope.name_search_str,0/*after*/).then(
            function(data){
                $scope.sp_lst = data;

                if(data.length === 0){
                    alert_service('no result found for ' + '"' + $scope.name_search_str + '"','info','blue');
                }else{
                    $scope.is_blur_infinite_scroll_triggerer_textbox = true;
                }
                
            }
            ,function(reason){ 
                alert_service(reason); 
            }
        )
    }

    $scope.infinite_scroll_handler = function(){
        if($scope.name_search_str.length === 0){
            //infinite scroll only apply for name search. because sku search does not have 'after' limit. Thus, when name_serch_str is empty, infinite_scroll_handler will do nothing
            return;
        }
        search_online_infinite_scroll_handler($scope,$scope.name_search_str,true/*is_name_only_or_name_sku*/,$scope.sp_lst);
    }

    //SORT
    $scope.cur_sort_column = 'name';
    $scope.cur_sort_desc = false;        

    $scope.infinite_scroll_reach_the_end = false; //WHY DO WE NEED THIS VAR? read the story inside search_online_infinite_scroll_handler()
    $scope.is_blur_infinite_scroll_triggerer_textbox = false;   

    $scope.sp_lst = [];        
    $scope.name_search_str = '';
    $scope.sku_search_str = '';

}]);
/*
    I could have include this file in the main app file. However, i factor this code out so i can exclude it from karma. WHY? 
    because _GLOBAL_SETTING_ is a constance passing down from the server in the html. This variable is not available in karma
    environment
*/
var mod = angular.module('app.productApp');
mod.requires.push.apply(mod.requires,[
    'app.construct_app_setting'
])

mod.value('share_setting',_GLOBAL_SETTING_);
mod.run(
[
    'app.construct_app_setting',
    'share_setting',
function(
    construct_app_setting,
    share_setting
){
    var constructed_share_setting = construct_app_setting(share_setting);
    for(var k in constructed_share_setting) 
        share_setting[k]=constructed_share_setting[k];
}]);

/*!
   angular-block-ui v0.2.1
   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui
   License: MIT
*/
(function(angular) {

var blkUI = angular.module('blockUI', []);

blkUI.config(["$provide", "$httpProvider", function ($provide, $httpProvider) {

  $provide.decorator('$exceptionHandler', ['$delegate', '$injector',
    function ($delegate, $injector) {
      var blockUI, blockUIConfig;

      return function (exception, cause) {

        blockUIConfig = blockUIConfig || $injector.get('blockUIConfig');

        if (blockUIConfig.resetOnException) {
          try {
            blockUI = blockUI || $injector.get('blockUI');
            blockUI.instances.reset();
          } catch (ex) {
            console.log('$exceptionHandler', exception);
          }
        }

        $delegate(exception, cause);
      };
    }
  ]);

  $httpProvider.interceptors.push('blockUIHttpInterceptor');
}]);

blkUI.run(["$document", "blockUIConfig", "$templateCache", function ($document, blockUIConfig, $templateCache) {
  if (blockUIConfig.autoInjectBodyBlock) {
    $document.find('body').attr('block-ui', 'main');
  }

  if (blockUIConfig.template) {

    // Swap the builtin template with the custom template.
    // Create a magic cache key and place the template in the cache.

    blockUIConfig.templateUrl = '$$block-ui-template$$';
    $templateCache.put(blockUIConfig.templateUrl, blockUIConfig.template);
  }
}]);

function moduleLoaded(name) {
  try {
    angular.module(name);
  } catch(ex) {
    return false;
  }
  return true;
}
blkUI.config(["$provide", function ($provide) {
  $provide.decorator('$location', decorateLocation);
}]);

var decorateLocation = [
  '$delegate', 'blockUI', 'blockUIConfig',
  function ($delegate, blockUI, blockUIConfig) {

    if (blockUIConfig.blockBrowserNavigation) {

      blockUI.$_blockLocationChange = true;

      var overrides = ['url', 'path', 'search', 'hash', 'state'];

      function hook(f) {
        var s = $delegate[f];
        $delegate[f] = function () {

          //        console.log(f, Date.now(), arguments);

          var result = s.apply($delegate, arguments);

          // The call was a setter if the $location service is returned.

          if (result === $delegate) {

            // Mark the mainblock ui to allow the location change.

            blockUI.$_blockLocationChange = false;
          }

          return result;
        };
      }

      angular.forEach(overrides, hook);

    }

    return $delegate;
}];

// Called from block-ui-directive for the 'main' instance.

function blockNavigation($scope, mainBlockUI, blockUIConfig) {

  if (blockUIConfig.blockBrowserNavigation) {

    function registerLocationChange() {

      $scope.$on('$locationChangeStart', function (event) {

        //        console.log('$locationChangeStart', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);

        if (mainBlockUI.$_blockLocationChange && mainBlockUI.state().blockCount > 0) {
          event.preventDefault();
        }
      });

      $scope.$on('$locationChangeSuccess', function () {
        mainBlockUI.$_blockLocationChange = blockUIConfig.blockBrowserNavigation;

        //        console.log('$locationChangeSuccess', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);
      });
    }

    if (moduleLoaded('ngRoute')) {

      // After the initial content has been loaded we'll spy on any location
      // changes and discard them when needed.

      var fn = $scope.$on('$viewContentLoaded', function () {

        // Unhook the view loaded and hook a function that will prevent
        // location changes while the block is active.

        fn();
        registerLocationChange();

      });

    } else {
      registerLocationChange();
    }

  }
}
blkUI.directive('blockUiContainer', ["blockUIConfig", "blockUiContainerLinkFn", function (blockUIConfig, blockUiContainerLinkFn) {
  return {
    scope: true,
    restrict: 'A',
    templateUrl: blockUIConfig.templateUrl,
    compile: function($element) {
      return blockUiContainerLinkFn;
    }
  };
}]).factory('blockUiContainerLinkFn', ["blockUI", "blockUIUtils", function (blockUI, blockUIUtils) {

  return function ($scope, $element, $attrs) {

    var srvInstance = $element.inheritedData('block-ui');

    if (!srvInstance) {
      throw new Error('No parent block-ui service instance located.');
    }

    // Expose the state on the scope

    $scope.state = srvInstance.state();

//    $scope.$watch('state.blocking', function(value) {
//      $element.toggleClass('block-ui-visible', !!value);
//    });
//
//    $scope.$watch('state.blockCount > 0', function(value) {
//      $element.toggleClass('block-ui-active', !!value);
//    });
  };
}]);
blkUI.directive('blockUi', ["blockUiCompileFn", function (blockUiCompileFn) {

  return {
    scope: true,
    restrict: 'A',
    compile: blockUiCompileFn
  };

}]).factory('blockUiCompileFn', ["blockUiPreLinkFn", function (blockUiPreLinkFn) {

  return function ($element, $attrs) {

    // Class should be added here to prevent an animation delay error.

    $element.append('<div block-ui-container class="block-ui-container"></div>');

    return {
      pre: blockUiPreLinkFn
    };

  };

}]).factory('blockUiPreLinkFn', ["blockUI", "blockUIUtils", "blockUIConfig", function (blockUI, blockUIUtils, blockUIConfig) {

  return function ($scope, $element, $attrs) {

    // If the element does not have the class "block-ui" set, we set the
    // default css classes from the config.

    if (!$element.hasClass('block-ui')) {
      $element.addClass(blockUIConfig.cssClass);
    }

    // Expose the blockUiMessageClass attribute value on the scope

    $attrs.$observe('blockUiMessageClass', function (value) {
      $scope.$_blockUiMessageClass = value;
    });

    // Create the blockUI instance
    // Prefix underscore to prevent integers:
    // https://github.com/McNull/angular-block-ui/pull/8

    var instanceId = $attrs.blockUi || '_' + $scope.$id;
    var srvInstance = blockUI.instances.get(instanceId);

    // If this is the main (topmost) block element we'll also need to block any
    // location changes while the block is active.

    if (instanceId === 'main') {
      blockNavigation($scope, srvInstance, blockUIConfig);
    } else {
      // Locate the parent blockUI instance
      var parentInstance = $element.inheritedData('block-ui');

      if (parentInstance) {
        // TODO: assert if parent is already set to something else
        srvInstance._parent = parentInstance;
      }
    }

    // Ensure the instance is released when the scope is destroyed

    $scope.$on('$destroy', function () {
      srvInstance.release();
    });

    // Increase the reference count

    srvInstance.addRef();

    // Expose the state on the scope

    $scope.$_blockUiState = srvInstance.state();

    $scope.$watch('$_blockUiState.blocking', function (value) {
      // Set the aria-busy attribute if needed
      $element.attr('aria-busy', !!value);
      $element.toggleClass('block-ui-visible', !!value);
    });

    $scope.$watch('$_blockUiState.blockCount > 0', function (value) {
      $element.toggleClass('block-ui-active', !!value);
    });

    // If a pattern is provided assign it to the state

    var pattern = $attrs.blockUiPattern;

    if (pattern) {
      var regExp = blockUIUtils.buildRegExp(pattern);
      srvInstance.pattern(regExp);
    }

    // Store a reference to the service instance on the element

    $element.data('block-ui', srvInstance);

  };

}]);
//.factory('blockUiPostLinkFn', function(blockUIUtils) {
//
//  return function($scope, $element, $attrs) {
//
//    var $message;
//
//    $attrs.$observe('blockUiMessageClass', function(value) {
//
//      $message = $message || blockUIUtils.findElement($element, function($e) {
//        return $e.hasClass('block-ui-message');
//      });
//
//      $message.addClass(value);
//
//    });
//  };
//
//});
blkUI.constant('blockUIConfig', {
    templateUrl: 'angular-block-ui/angular-block-ui.ng.html',
    delay: 250,
    message: "Loading ...",
    autoBlock: true,
    resetOnException: true,
    requestFilter: angular.noop,
    autoInjectBodyBlock: true,
    cssClass: 'block-ui block-ui-anim-fade',
    blockBrowserNavigation: false
});


blkUI.factory('blockUIHttpInterceptor', ["$q", "$injector", "blockUIConfig", "$templateCache", function($q, $injector, blockUIConfig, $templateCache) {

  var blockUI;

  function injectBlockUI() {
    blockUI = blockUI || $injector.get('blockUI');
  }

  function stopBlockUI(config) {
    if (blockUIConfig.autoBlock && (config && !config.$_noBlock && config.$_blocks)) {
      injectBlockUI();
      config.$_blocks.stop();
    }
  }

  function error(rejection) {

    try {
      stopBlockUI(rejection.config);
    } catch(ex) {
      console.log('httpRequestError', ex);
    }

    return $q.reject(rejection);
  }

  return {
    request: function(config) {

      // Only block when autoBlock is enabled ...
      // ... and the request doesn't match a cached template.

      if (blockUIConfig.autoBlock &&
        !(config.method == 'GET' && $templateCache.get(config.url))) {

        // Don't block excluded requests

        var result = blockUIConfig.requestFilter(config);

        if (result === false) {
          // Tag the config so we don't unblock this request
          config.$_noBlock = true;
        } else {

          injectBlockUI();

          config.$_blocks = blockUI.instances.locate(config);
          config.$_blocks.start(result);
        }
      }

      return config;
    },

    requestError: error,

    response: function(response) {

      // If the connection to the website goes down the response interceptor gets and error with "cannot read property config of null".
      // https://github.com/McNull/angular-block-ui/issues/53

      if(response) {
        stopBlockUI(response.config);
      }

      return response;
    },

    responseError: error
  };

}]);

blkUI.factory('blockUI', ["blockUIConfig", "$timeout", "blockUIUtils", "$document", function(blockUIConfig, $timeout, blockUIUtils, $document) {

  var $body = $document.find('body');
  
  // These properties are not allowed to be specified in the start method.
  var reservedStateProperties = ['id', 'blockCount', 'blocking'];
  
  function BlockUI(id) {

    var self = this;

    var state = {
      id: id,
      blockCount: 0,
      message: blockUIConfig.message,
      blocking: false
    }, startPromise, doneCallbacks = [];

    this._id = id;

    this._refs = 0;

    this.start = function(messageOrOptions) {
      
      messageOrOptions = messageOrOptions || {};
      
      if(angular.isString(messageOrOptions)) {
        messageOrOptions = {
          message: messageOrOptions
        };
      } else {
        angular.forEach(reservedStateProperties, function(x) {
          if(messageOrOptions[x]) {
            throw new Error('The property ' + x + ' is reserved for the block state.');
          }
        });
      } 
      
      angular.extend(state, messageOrOptions);
      
      if(state.blockCount > 0) {
        state.message = messageOrOptions.message || state.message || blockUIConfig.message;
      } else {
        state.message = messageOrOptions.message || blockUIConfig.message;
      }
      
      // if(state.blockCount > 0) {
      //   messageOrOptions = messageOrOptions || state.message || blockUIConfig.message;
      // } else {
      //   messageOrOptions = messageOrOptions || blockUIConfig.message;
      // }

      // state.message = messageOrOptions;

      state.blockCount++;

      // Check if the focused element is part of the block scope

      var $ae = angular.element($document[0].activeElement);

      if($ae.length && blockUIUtils.isElementInBlockScope($ae, self)) {

        // Let the active element lose focus and store a reference 
        // to restore focus when we're done (reset)

        self._restoreFocus = $ae[0];

        // https://github.com/McNull/angular-block-ui/issues/13
        // http://stackoverflow.com/questions/22698058/apply-already-in-progress-error-when-using-typeahead-plugin-found-to-be-relate
        // Queue the blur after any ng-blur expression.

        $timeout(function() {
          // Ensure we still need to blur
          // Don't restore if active element is body, since this causes IE to switch windows (see http://tjvantoll.com/2013/08/30/bugs-with-document-activeelement-in-internet-explorer/)
          if (self._restoreFocus && self._restoreFocus !== $body[0]) {
            self._restoreFocus.blur();
          }
        });
      }

      if (!startPromise && blockUIConfig.delay !== 0) {
        startPromise = $timeout(block, blockUIConfig.delay);
      } else if (blockUIConfig.delay === 0) {
        block();
      }

      function block () {
        startPromise = null;
        state.blocking = true;
      }
    };

    this._cancelStartTimeout = function() {
      if (startPromise) {
        $timeout.cancel(startPromise);
        startPromise = null;
      }
    };

    this.stop = function() {
      state.blockCount = Math.max(0, --state.blockCount);

      if (state.blockCount === 0) {
        self.reset(true);
      }
    };

    this.isBlocking = function () {
        return state.blocking;
    };

    this.message = function(value) {
      state.message = value;
    };

    this.pattern = function(regexp) {
      if (regexp !== undefined) {
        self._pattern = regexp;
      }

      return self._pattern;
    };

    this.reset = function(executeCallbacks) {
      
      self._cancelStartTimeout();
      state.blockCount = 0;
      state.blocking = false;

      // Restore the focus to the element that was active
      // before the block start, but not if the user has 
      // focused something else while the block was active.

      if(self._restoreFocus && 
         (!$document[0].activeElement || $document[0].activeElement === $body[0])) {
        
        //IE8 will throw if element for setting focus is invisible
        try {
          self._restoreFocus.focus();
        } catch(e1) {
          (function () {
              var elementToFocus = self._restoreFocus;
              $timeout(function() { 
                if(elementToFocus) { 
                  try { 
                    elementToFocus.focus(); 
                  } catch(e2) { }
              } 
            },100);
          })();
        }
        
        self._restoreFocus = null;
      }
      
      try {
        if (executeCallbacks) {
          angular.forEach(doneCallbacks, function(cb) {
            cb();
          });
        }
      } finally {
        doneCallbacks.length = 0;
      }
    };

    this.done = function(fn) {
      doneCallbacks.push(fn);
    };

    this.state = function() {
      return state;
    };

    this.addRef = function() {
      self._refs += 1;
    };

    this.release = function() {
      if(--self._refs <= 0) {
        mainBlock.instances._destroy(self);
      }
    };
  }

  var instances = [];

  instances.get = function(id) {

    if(!isNaN(id)) {
      throw new Error('BlockUI id cannot be a number');
    }

    var instance = instances[id];

    if(!instance) {
      // TODO: ensure no array instance trashing [xxx] -- current workaround: '_' + $scope.$id
      instance = instances[id] = new BlockUI(id);
      instances.push(instance);
    }

    return instance;
  };

  instances._destroy = function(idOrInstance) {
    if (angular.isString(idOrInstance)) {
      idOrInstance = instances[idOrInstance];
    }

    if (idOrInstance) {
      idOrInstance.reset();

      var i = blockUIUtils.indexOf(instances, idOrInstance);
      instances.splice(i, 1);

      delete instances[idOrInstance.state().id];
    }
  };
  
  instances.locate = function(request) {

    var result = [];

    // Add function wrappers that will be executed on every item
    // in the array.
    
    blockUIUtils.forEachFnHook(result, 'start');
    blockUIUtils.forEachFnHook(result, 'stop');

    var i = instances.length;

    while(i--) {
      var instance = instances[i];
      var pattern = instance._pattern;

      if(pattern && pattern.test(request.url)) {
        result.push(instance);
      }
    }

    if(result.length === 0) {
      result.push(mainBlock);
    }

    return result;
  };

  // Propagate the reset to all instances

  blockUIUtils.forEachFnHook(instances, 'reset');

  var mainBlock = instances.get('main');

  mainBlock.addRef();
  mainBlock.instances = instances;

  return mainBlock;
}]);


blkUI.factory('blockUIUtils', function() {

  var $ = angular.element;

  var utils = {
    buildRegExp: function(pattern) {
      var match = pattern.match(/^\/(.*)\/([gim]*)$/), regExp;

      if(match) {
        regExp = new RegExp(match[1], match[2]);
      } else {
        throw Error('Incorrect regular expression format: ' + pattern);
      }

      return regExp;
    },
    forEachFn: function(arr, fnName, args) {
      var i = arr.length;
      while(i--) {
        var t = arr[i];
        t[fnName].apply(t, args);
      }
    },
    forEachFnHook: function(arr, fnName) {
      arr[fnName] = function() {
        utils.forEachFn(this, fnName, arguments);
      }
    },
    isElementInBlockScope: function($element, blockScope) {
      var c = $element.inheritedData('block-ui');

      while(c) {
        if(c === blockScope) {
          return true;
        }

        c = c._parent;
      }

      return false;
    },
    findElement: function ($element, predicateFn, traverse) {
      var ret = null;

      if (predicateFn($element)) {
        ret = $element;
      } else {

        var $elements;

        if (traverse) {
          $elements = $element.parent();
        } else {
          $elements = $element.children();
        }

        var i = $elements.length;
        while (!ret && i--) {
          ret = utils.findElement($($elements[i]), predicateFn, traverse);
        }
      }

      return ret;
    },
    indexOf: function(arr, obj, start) {
//      if(Array.prototype.indexOf) {
//        return arr.indexOf(obj, start);
//      }

      for (var i = (start || 0), j = arr.length; i < j; i++) {
        if (arr[i] === obj) {
          return i;
        }
      }

      return -1;
    }
  };

  return utils;

});
// Automatically generated.
// This file is already embedded in your main javascript output, there's no need to include this file
// manually in the index.html. This file is only here for your debugging pleasures.
angular.module('blockUI').run(['$templateCache', function($templateCache){
  $templateCache.put('angular-block-ui/angular-block-ui.ng.html', '<div class=\"block-ui-overlay\"></div><div class=\"block-ui-message-container\" aria-live=\"assertive\" aria-atomic=\"true\"><div class=\"block-ui-message\" ng-class=\"$_blockUiMessageClass\">{{ state.message }}</div></div>');
}]);
})(angular);
//# sourceMappingURL=angular-block-ui.js.map
/* ng-infinite-scroll - v1.2.0 - 2015-12-02 */
var mod;

mod = angular.module('infinite-scroll', []);

mod.value('THROTTLE_MILLISECONDS', null);

mod.directive('infiniteScroll', [
  '$rootScope', '$window', '$interval', 'THROTTLE_MILLISECONDS', function($rootScope, $window, $interval, THROTTLE_MILLISECONDS) {
    return {
      scope: {
        infiniteScroll: '&',
        infiniteScrollContainer: '=',
        infiniteScrollDistance: '=',
        infiniteScrollDisabled: '=',
        infiniteScrollUseDocumentBottom: '=',
        infiniteScrollListenForEvent: '@'
      },
      link: function(scope, elem, attrs) {
        var changeContainer, checkInterval, checkWhenEnabled, container, handleInfiniteScrollContainer, handleInfiniteScrollDisabled, handleInfiniteScrollDistance, handleInfiniteScrollUseDocumentBottom, handler, height, immediateCheck, offsetTop, pageYOffset, scrollDistance, scrollEnabled, throttle, unregisterEventListener, useDocumentBottom, windowElement;
        windowElement = angular.element($window);
        scrollDistance = null;
        scrollEnabled = null;
        checkWhenEnabled = null;
        container = null;
        immediateCheck = true;
        useDocumentBottom = false;
        unregisterEventListener = null;
        checkInterval = false;
        height = function(elem) {
          elem = elem[0] || elem;
          if (isNaN(elem.offsetHeight)) {
            return elem.document.documentElement.clientHeight;
          } else {
            return elem.offsetHeight;
          }
        };
        offsetTop = function(elem) {
          if (!elem[0].getBoundingClientRect || elem.css('none')) {
            return;
          }
          return elem[0].getBoundingClientRect().top + pageYOffset(elem);
        };
        pageYOffset = function(elem) {
          elem = elem[0] || elem;
          if (isNaN(window.pageYOffset)) {
            return elem.document.documentElement.scrollTop;
          } else {
            return elem.ownerDocument.defaultView.pageYOffset;
          }
        };
        handler = function() {
          var containerBottom, containerTopOffset, elementBottom, remaining, shouldScroll;
          if (container === windowElement) {
            containerBottom = height(container) + pageYOffset(container[0].document.documentElement);
            elementBottom = offsetTop(elem) + height(elem);
          } else {
            containerBottom = height(container);
            containerTopOffset = 0;
            if (offsetTop(container) !== void 0) {
              containerTopOffset = offsetTop(container);
            }
            elementBottom = offsetTop(elem) - containerTopOffset + height(elem);
          }
          if (useDocumentBottom) {
            elementBottom = height((elem[0].ownerDocument || elem[0].document).documentElement);
          }
          remaining = elementBottom - containerBottom;
          shouldScroll = remaining <= height(container) * scrollDistance + 1;
          if (shouldScroll) {
            checkWhenEnabled = true;
            if (scrollEnabled) {
              if (scope.$$phase || $rootScope.$$phase) {
                return scope.infiniteScroll();
              } else {
                return scope.$apply(scope.infiniteScroll);
              }
            }
          } else {
            if (checkInterval) {
              $interval.cancel(checkInterval);
            }
            return checkWhenEnabled = false;
          }
        };
        throttle = function(func, wait) {
          var later, previous, timeout;
          timeout = null;
          previous = 0;
          later = function() {
            var context;
            previous = new Date().getTime();
            $interval.cancel(timeout);
            timeout = null;
            func.call();
            return context = null;
          };
          return function() {
            var now, remaining;
            now = new Date().getTime();
            remaining = wait - (now - previous);
            if (remaining <= 0) {
              clearTimeout(timeout);
              $interval.cancel(timeout);
              timeout = null;
              previous = now;
              return func.call();
            } else {
              if (!timeout) {
                return timeout = $interval(later, remaining, 1);
              }
            }
          };
        };
        if (THROTTLE_MILLISECONDS != null) {
          handler = throttle(handler, THROTTLE_MILLISECONDS);
        }
        scope.$on('$destroy', function() {
          container.unbind('scroll', handler);
          if (unregisterEventListener != null) {
            unregisterEventListener();
            return unregisterEventListener = null;
          }
        });
        handleInfiniteScrollDistance = function(v) {
          return scrollDistance = parseFloat(v) || 0;
        };
        scope.$watch('infiniteScrollDistance', handleInfiniteScrollDistance);
        handleInfiniteScrollDistance(scope.infiniteScrollDistance);
        handleInfiniteScrollDisabled = function(v) {
          scrollEnabled = !v;
          if (scrollEnabled && checkWhenEnabled) {
            checkWhenEnabled = false;
            return handler();
          }
        };
        scope.$watch('infiniteScrollDisabled', handleInfiniteScrollDisabled);
        handleInfiniteScrollDisabled(scope.infiniteScrollDisabled);
        handleInfiniteScrollUseDocumentBottom = function(v) {
          return useDocumentBottom = v;
        };
        scope.$watch('infiniteScrollUseDocumentBottom', handleInfiniteScrollUseDocumentBottom);
        handleInfiniteScrollUseDocumentBottom(scope.infiniteScrollUseDocumentBottom);
        changeContainer = function(newContainer) {
          if (container != null) {
            container.unbind('scroll', handler);
          }
          container = newContainer;
          if (newContainer != null) {
            return container.bind('scroll', handler);
          }
        };
        changeContainer(windowElement);
        if (scope.infiniteScrollListenForEvent) {
          unregisterEventListener = $rootScope.$on(scope.infiniteScrollListenForEvent, handler);
        }
        handleInfiniteScrollContainer = function(newContainer) {
          if ((newContainer == null) || newContainer.length === 0) {
            return;
          }
          if (newContainer instanceof HTMLElement) {
            newContainer = angular.element(newContainer);
          } else if (typeof newContainer.append === 'function') {
            newContainer = angular.element(newContainer[newContainer.length - 1]);
          } else if (typeof newContainer === 'string') {
            newContainer = angular.element(document.querySelector(newContainer));
          }
          if (newContainer != null) {
            return changeContainer(newContainer);
          } else {
            throw new Exception("invalid infinite-scroll-container attribute.");
          }
        };
        scope.$watch('infiniteScrollContainer', handleInfiniteScrollContainer);
        handleInfiniteScrollContainer(scope.infiniteScrollContainer || []);
        if (attrs.infiniteScrollParent != null) {
          changeContainer(angular.element(elem.parent()));
        }
        if (attrs.infiniteScrollImmediateCheck != null) {
          immediateCheck = scope.$eval(attrs.infiniteScrollImmediateCheck);
        }
        return checkInterval = $interval((function() {
          if (immediateCheck) {
            return handler();
          }
        }), 0);
      }
    };
  }
]);
