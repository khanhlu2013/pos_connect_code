var mod = angular.module('app.productApp',[]);
var mod = angular.module('app.saleApp',[]);
var mod = angular.module('model.group',[]);


var mod = angular.module('model.mix_match',[]);
var mod = angular.module('model.non_inventory',[]);

angular.module('model.product',[]);
var mod = angular.module('model.receipt',[])
var mod = angular.module('model.report',[]);
var mod = angular.module('model.store',[]);
angular.module('model.store_product',[]);
var mod = angular.module('share.menu',[])
var mod = angular.module('share.ui',[]);
var mod = angular.module('share.util',[]);

/*!
   angular-block-ui v0.2.1
   (c) 2015 (null) McNull https://github.com/McNull/angular-block-ui
   License: MIT
*/
(function(angular) {

var blkUI = angular.module('blockUI', []);

blkUI.config(["$provide", "$httpProvider", function ($provide, $httpProvider) {

  $provide.decorator('$exceptionHandler', ['$delegate', '$injector',
    function ($delegate, $injector) {
      var blockUI, blockUIConfig;

      return function (exception, cause) {

        blockUIConfig = blockUIConfig || $injector.get('blockUIConfig');

        if (blockUIConfig.resetOnException) {
          try {
            blockUI = blockUI || $injector.get('blockUI');
            blockUI.instances.reset();
          } catch (ex) {
            console.log('$exceptionHandler', exception);
          }
        }

        $delegate(exception, cause);
      };
    }
  ]);

  $httpProvider.interceptors.push('blockUIHttpInterceptor');
}]);

blkUI.run(["$document", "blockUIConfig", "$templateCache", function ($document, blockUIConfig, $templateCache) {
  if (blockUIConfig.autoInjectBodyBlock) {
    $document.find('body').attr('block-ui', 'main');
  }

  if (blockUIConfig.template) {

    // Swap the builtin template with the custom template.
    // Create a magic cache key and place the template in the cache.

    blockUIConfig.templateUrl = '$$block-ui-template$$';
    $templateCache.put(blockUIConfig.templateUrl, blockUIConfig.template);
  }
}]);

function moduleLoaded(name) {
  try {
    angular.module(name);
  } catch(ex) {
    return false;
  }
  return true;
}
blkUI.config(["$provide", function ($provide) {
  $provide.decorator('$location', decorateLocation);
}]);

var decorateLocation = [
  '$delegate', 'blockUI', 'blockUIConfig',
  function ($delegate, blockUI, blockUIConfig) {

    if (blockUIConfig.blockBrowserNavigation) {

      blockUI.$_blockLocationChange = true;

      var overrides = ['url', 'path', 'search', 'hash', 'state'];

      function hook(f) {
        var s = $delegate[f];
        $delegate[f] = function () {

          //        console.log(f, Date.now(), arguments);

          var result = s.apply($delegate, arguments);

          // The call was a setter if the $location service is returned.

          if (result === $delegate) {

            // Mark the mainblock ui to allow the location change.

            blockUI.$_blockLocationChange = false;
          }

          return result;
        };
      }

      angular.forEach(overrides, hook);

    }

    return $delegate;
}];

// Called from block-ui-directive for the 'main' instance.

function blockNavigation($scope, mainBlockUI, blockUIConfig) {

  if (blockUIConfig.blockBrowserNavigation) {

    function registerLocationChange() {

      $scope.$on('$locationChangeStart', function (event) {

        //        console.log('$locationChangeStart', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);

        if (mainBlockUI.$_blockLocationChange && mainBlockUI.state().blockCount > 0) {
          event.preventDefault();
        }
      });

      $scope.$on('$locationChangeSuccess', function () {
        mainBlockUI.$_blockLocationChange = blockUIConfig.blockBrowserNavigation;

        //        console.log('$locationChangeSuccess', mainBlockUI.$_blockLocationChange + ' ' + mainBlockUI.state().blockCount);
      });
    }

    if (moduleLoaded('ngRoute')) {

      // After the initial content has been loaded we'll spy on any location
      // changes and discard them when needed.

      var fn = $scope.$on('$viewContentLoaded', function () {

        // Unhook the view loaded and hook a function that will prevent
        // location changes while the block is active.

        fn();
        registerLocationChange();

      });

    } else {
      registerLocationChange();
    }

  }
}
blkUI.directive('blockUiContainer', ["blockUIConfig", "blockUiContainerLinkFn", function (blockUIConfig, blockUiContainerLinkFn) {
  return {
    scope: true,
    restrict: 'A',
    templateUrl: blockUIConfig.templateUrl,
    compile: function($element) {
      return blockUiContainerLinkFn;
    }
  };
}]).factory('blockUiContainerLinkFn', ["blockUI", "blockUIUtils", function (blockUI, blockUIUtils) {

  return function ($scope, $element, $attrs) {

    var srvInstance = $element.inheritedData('block-ui');

    if (!srvInstance) {
      throw new Error('No parent block-ui service instance located.');
    }

    // Expose the state on the scope

    $scope.state = srvInstance.state();

//    $scope.$watch('state.blocking', function(value) {
//      $element.toggleClass('block-ui-visible', !!value);
//    });
//
//    $scope.$watch('state.blockCount > 0', function(value) {
//      $element.toggleClass('block-ui-active', !!value);
//    });
  };
}]);
blkUI.directive('blockUi', ["blockUiCompileFn", function (blockUiCompileFn) {

  return {
    scope: true,
    restrict: 'A',
    compile: blockUiCompileFn
  };

}]).factory('blockUiCompileFn', ["blockUiPreLinkFn", function (blockUiPreLinkFn) {

  return function ($element, $attrs) {

    // Class should be added here to prevent an animation delay error.

    $element.append('<div block-ui-container class="block-ui-container"></div>');

    return {
      pre: blockUiPreLinkFn
    };

  };

}]).factory('blockUiPreLinkFn', ["blockUI", "blockUIUtils", "blockUIConfig", function (blockUI, blockUIUtils, blockUIConfig) {

  return function ($scope, $element, $attrs) {

    // If the element does not have the class "block-ui" set, we set the
    // default css classes from the config.

    if (!$element.hasClass('block-ui')) {
      $element.addClass(blockUIConfig.cssClass);
    }

    // Expose the blockUiMessageClass attribute value on the scope

    $attrs.$observe('blockUiMessageClass', function (value) {
      $scope.$_blockUiMessageClass = value;
    });

    // Create the blockUI instance
    // Prefix underscore to prevent integers:
    // https://github.com/McNull/angular-block-ui/pull/8

    var instanceId = $attrs.blockUi || '_' + $scope.$id;
    var srvInstance = blockUI.instances.get(instanceId);

    // If this is the main (topmost) block element we'll also need to block any
    // location changes while the block is active.

    if (instanceId === 'main') {
      blockNavigation($scope, srvInstance, blockUIConfig);
    } else {
      // Locate the parent blockUI instance
      var parentInstance = $element.inheritedData('block-ui');

      if (parentInstance) {
        // TODO: assert if parent is already set to something else
        srvInstance._parent = parentInstance;
      }
    }

    // Ensure the instance is released when the scope is destroyed

    $scope.$on('$destroy', function () {
      srvInstance.release();
    });

    // Increase the reference count

    srvInstance.addRef();

    // Expose the state on the scope

    $scope.$_blockUiState = srvInstance.state();

    $scope.$watch('$_blockUiState.blocking', function (value) {
      // Set the aria-busy attribute if needed
      $element.attr('aria-busy', !!value);
      $element.toggleClass('block-ui-visible', !!value);
    });

    $scope.$watch('$_blockUiState.blockCount > 0', function (value) {
      $element.toggleClass('block-ui-active', !!value);
    });

    // If a pattern is provided assign it to the state

    var pattern = $attrs.blockUiPattern;

    if (pattern) {
      var regExp = blockUIUtils.buildRegExp(pattern);
      srvInstance.pattern(regExp);
    }

    // Store a reference to the service instance on the element

    $element.data('block-ui', srvInstance);

  };

}]);
//.factory('blockUiPostLinkFn', function(blockUIUtils) {
//
//  return function($scope, $element, $attrs) {
//
//    var $message;
//
//    $attrs.$observe('blockUiMessageClass', function(value) {
//
//      $message = $message || blockUIUtils.findElement($element, function($e) {
//        return $e.hasClass('block-ui-message');
//      });
//
//      $message.addClass(value);
//
//    });
//  };
//
//});
blkUI.constant('blockUIConfig', {
    templateUrl: 'angular-block-ui/angular-block-ui.ng.html',
    delay: 250,
    message: "Loading ...",
    autoBlock: true,
    resetOnException: true,
    requestFilter: angular.noop,
    autoInjectBodyBlock: true,
    cssClass: 'block-ui block-ui-anim-fade',
    blockBrowserNavigation: false
});


blkUI.factory('blockUIHttpInterceptor', ["$q", "$injector", "blockUIConfig", "$templateCache", function($q, $injector, blockUIConfig, $templateCache) {

  var blockUI;

  function injectBlockUI() {
    blockUI = blockUI || $injector.get('blockUI');
  }

  function stopBlockUI(config) {
    if (blockUIConfig.autoBlock && (config && !config.$_noBlock && config.$_blocks)) {
      injectBlockUI();
      config.$_blocks.stop();
    }
  }

  function error(rejection) {

    try {
      stopBlockUI(rejection.config);
    } catch(ex) {
      console.log('httpRequestError', ex);
    }

    return $q.reject(rejection);
  }

  return {
    request: function(config) {

      // Only block when autoBlock is enabled ...
      // ... and the request doesn't match a cached template.

      if (blockUIConfig.autoBlock &&
        !(config.method == 'GET' && $templateCache.get(config.url))) {

        // Don't block excluded requests

        var result = blockUIConfig.requestFilter(config);

        if (result === false) {
          // Tag the config so we don't unblock this request
          config.$_noBlock = true;
        } else {

          injectBlockUI();

          config.$_blocks = blockUI.instances.locate(config);
          config.$_blocks.start(result);
        }
      }

      return config;
    },

    requestError: error,

    response: function(response) {

      // If the connection to the website goes down the response interceptor gets and error with "cannot read property config of null".
      // https://github.com/McNull/angular-block-ui/issues/53

      if(response) {
        stopBlockUI(response.config);
      }

      return response;
    },

    responseError: error
  };

}]);

blkUI.factory('blockUI', ["blockUIConfig", "$timeout", "blockUIUtils", "$document", function(blockUIConfig, $timeout, blockUIUtils, $document) {

  var $body = $document.find('body');
  
  // These properties are not allowed to be specified in the start method.
  var reservedStateProperties = ['id', 'blockCount', 'blocking'];
  
  function BlockUI(id) {

    var self = this;

    var state = {
      id: id,
      blockCount: 0,
      message: blockUIConfig.message,
      blocking: false
    }, startPromise, doneCallbacks = [];

    this._id = id;

    this._refs = 0;

    this.start = function(messageOrOptions) {
      
      messageOrOptions = messageOrOptions || {};
      
      if(angular.isString(messageOrOptions)) {
        messageOrOptions = {
          message: messageOrOptions
        };
      } else {
        angular.forEach(reservedStateProperties, function(x) {
          if(messageOrOptions[x]) {
            throw new Error('The property ' + x + ' is reserved for the block state.');
          }
        });
      } 
      
      angular.extend(state, messageOrOptions);
      
      if(state.blockCount > 0) {
        state.message = messageOrOptions.message || state.message || blockUIConfig.message;
      } else {
        state.message = messageOrOptions.message || blockUIConfig.message;
      }
      
      // if(state.blockCount > 0) {
      //   messageOrOptions = messageOrOptions || state.message || blockUIConfig.message;
      // } else {
      //   messageOrOptions = messageOrOptions || blockUIConfig.message;
      // }

      // state.message = messageOrOptions;

      state.blockCount++;

      // Check if the focused element is part of the block scope

      var $ae = angular.element($document[0].activeElement);

      if($ae.length && blockUIUtils.isElementInBlockScope($ae, self)) {

        // Let the active element lose focus and store a reference 
        // to restore focus when we're done (reset)

        self._restoreFocus = $ae[0];

        // https://github.com/McNull/angular-block-ui/issues/13
        // http://stackoverflow.com/questions/22698058/apply-already-in-progress-error-when-using-typeahead-plugin-found-to-be-relate
        // Queue the blur after any ng-blur expression.

        $timeout(function() {
          // Ensure we still need to blur
          // Don't restore if active element is body, since this causes IE to switch windows (see http://tjvantoll.com/2013/08/30/bugs-with-document-activeelement-in-internet-explorer/)
          if (self._restoreFocus && self._restoreFocus !== $body[0]) {
            self._restoreFocus.blur();
          }
        });
      }

      if (!startPromise && blockUIConfig.delay !== 0) {
        startPromise = $timeout(block, blockUIConfig.delay);
      } else if (blockUIConfig.delay === 0) {
        block();
      }

      function block () {
        startPromise = null;
        state.blocking = true;
      }
    };

    this._cancelStartTimeout = function() {
      if (startPromise) {
        $timeout.cancel(startPromise);
        startPromise = null;
      }
    };

    this.stop = function() {
      state.blockCount = Math.max(0, --state.blockCount);

      if (state.blockCount === 0) {
        self.reset(true);
      }
    };

    this.isBlocking = function () {
        return state.blocking;
    };

    this.message = function(value) {
      state.message = value;
    };

    this.pattern = function(regexp) {
      if (regexp !== undefined) {
        self._pattern = regexp;
      }

      return self._pattern;
    };

    this.reset = function(executeCallbacks) {
      
      self._cancelStartTimeout();
      state.blockCount = 0;
      state.blocking = false;

      // Restore the focus to the element that was active
      // before the block start, but not if the user has 
      // focused something else while the block was active.

      if(self._restoreFocus && 
         (!$document[0].activeElement || $document[0].activeElement === $body[0])) {
        
        //IE8 will throw if element for setting focus is invisible
        try {
          self._restoreFocus.focus();
        } catch(e1) {
          (function () {
              var elementToFocus = self._restoreFocus;
              $timeout(function() { 
                if(elementToFocus) { 
                  try { 
                    elementToFocus.focus(); 
                  } catch(e2) { }
              } 
            },100);
          })();
        }
        
        self._restoreFocus = null;
      }
      
      try {
        if (executeCallbacks) {
          angular.forEach(doneCallbacks, function(cb) {
            cb();
          });
        }
      } finally {
        doneCallbacks.length = 0;
      }
    };

    this.done = function(fn) {
      doneCallbacks.push(fn);
    };

    this.state = function() {
      return state;
    };

    this.addRef = function() {
      self._refs += 1;
    };

    this.release = function() {
      if(--self._refs <= 0) {
        mainBlock.instances._destroy(self);
      }
    };
  }

  var instances = [];

  instances.get = function(id) {

    if(!isNaN(id)) {
      throw new Error('BlockUI id cannot be a number');
    }

    var instance = instances[id];

    if(!instance) {
      // TODO: ensure no array instance trashing [xxx] -- current workaround: '_' + $scope.$id
      instance = instances[id] = new BlockUI(id);
      instances.push(instance);
    }

    return instance;
  };

  instances._destroy = function(idOrInstance) {
    if (angular.isString(idOrInstance)) {
      idOrInstance = instances[idOrInstance];
    }

    if (idOrInstance) {
      idOrInstance.reset();

      var i = blockUIUtils.indexOf(instances, idOrInstance);
      instances.splice(i, 1);

      delete instances[idOrInstance.state().id];
    }
  };
  
  instances.locate = function(request) {

    var result = [];

    // Add function wrappers that will be executed on every item
    // in the array.
    
    blockUIUtils.forEachFnHook(result, 'start');
    blockUIUtils.forEachFnHook(result, 'stop');

    var i = instances.length;

    while(i--) {
      var instance = instances[i];
      var pattern = instance._pattern;

      if(pattern && pattern.test(request.url)) {
        result.push(instance);
      }
    }

    if(result.length === 0) {
      result.push(mainBlock);
    }

    return result;
  };

  // Propagate the reset to all instances

  blockUIUtils.forEachFnHook(instances, 'reset');

  var mainBlock = instances.get('main');

  mainBlock.addRef();
  mainBlock.instances = instances;

  return mainBlock;
}]);


blkUI.factory('blockUIUtils', function() {

  var $ = angular.element;

  var utils = {
    buildRegExp: function(pattern) {
      var match = pattern.match(/^\/(.*)\/([gim]*)$/), regExp;

      if(match) {
        regExp = new RegExp(match[1], match[2]);
      } else {
        throw Error('Incorrect regular expression format: ' + pattern);
      }

      return regExp;
    },
    forEachFn: function(arr, fnName, args) {
      var i = arr.length;
      while(i--) {
        var t = arr[i];
        t[fnName].apply(t, args);
      }
    },
    forEachFnHook: function(arr, fnName) {
      arr[fnName] = function() {
        utils.forEachFn(this, fnName, arguments);
      }
    },
    isElementInBlockScope: function($element, blockScope) {
      var c = $element.inheritedData('block-ui');

      while(c) {
        if(c === blockScope) {
          return true;
        }

        c = c._parent;
      }

      return false;
    },
    findElement: function ($element, predicateFn, traverse) {
      var ret = null;

      if (predicateFn($element)) {
        ret = $element;
      } else {

        var $elements;

        if (traverse) {
          $elements = $element.parent();
        } else {
          $elements = $element.children();
        }

        var i = $elements.length;
        while (!ret && i--) {
          ret = utils.findElement($($elements[i]), predicateFn, traverse);
        }
      }

      return ret;
    },
    indexOf: function(arr, obj, start) {
//      if(Array.prototype.indexOf) {
//        return arr.indexOf(obj, start);
//      }

      for (var i = (start || 0), j = arr.length; i < j; i++) {
        if (arr[i] === obj) {
          return i;
        }
      }

      return -1;
    }
  };

  return utils;

});
// Automatically generated.
// This file is already embedded in your main javascript output, there's no need to include this file
// manually in the index.html. This file is only here for your debugging pleasures.
angular.module('blockUI').run(['$templateCache', function($templateCache){
  $templateCache.put('angular-block-ui/angular-block-ui.ng.html', '<div class=\"block-ui-overlay\"></div><div class=\"block-ui-message-container\" aria-live=\"assertive\" aria-atomic=\"true\"><div class=\"block-ui-message\" ng-class=\"$_blockUiMessageClass\">{{ state.message }}</div></div>');
}]);
})(angular);
//# sourceMappingURL=angular-block-ui.js.map
/* ng-infinite-scroll - v1.2.0 - 2015-12-02 */
var mod;

mod = angular.module('infinite-scroll', []);

mod.value('THROTTLE_MILLISECONDS', null);

mod.directive('infiniteScroll', [
  '$rootScope', '$window', '$interval', 'THROTTLE_MILLISECONDS', function($rootScope, $window, $interval, THROTTLE_MILLISECONDS) {
    return {
      scope: {
        infiniteScroll: '&',
        infiniteScrollContainer: '=',
        infiniteScrollDistance: '=',
        infiniteScrollDisabled: '=',
        infiniteScrollUseDocumentBottom: '=',
        infiniteScrollListenForEvent: '@'
      },
      link: function(scope, elem, attrs) {
        var changeContainer, checkInterval, checkWhenEnabled, container, handleInfiniteScrollContainer, handleInfiniteScrollDisabled, handleInfiniteScrollDistance, handleInfiniteScrollUseDocumentBottom, handler, height, immediateCheck, offsetTop, pageYOffset, scrollDistance, scrollEnabled, throttle, unregisterEventListener, useDocumentBottom, windowElement;
        windowElement = angular.element($window);
        scrollDistance = null;
        scrollEnabled = null;
        checkWhenEnabled = null;
        container = null;
        immediateCheck = true;
        useDocumentBottom = false;
        unregisterEventListener = null;
        checkInterval = false;
        height = function(elem) {
          elem = elem[0] || elem;
          if (isNaN(elem.offsetHeight)) {
            return elem.document.documentElement.clientHeight;
          } else {
            return elem.offsetHeight;
          }
        };
        offsetTop = function(elem) {
          if (!elem[0].getBoundingClientRect || elem.css('none')) {
            return;
          }
          return elem[0].getBoundingClientRect().top + pageYOffset(elem);
        };
        pageYOffset = function(elem) {
          elem = elem[0] || elem;
          if (isNaN(window.pageYOffset)) {
            return elem.document.documentElement.scrollTop;
          } else {
            return elem.ownerDocument.defaultView.pageYOffset;
          }
        };
        handler = function() {
          var containerBottom, containerTopOffset, elementBottom, remaining, shouldScroll;
          if (container === windowElement) {
            containerBottom = height(container) + pageYOffset(container[0].document.documentElement);
            elementBottom = offsetTop(elem) + height(elem);
          } else {
            containerBottom = height(container);
            containerTopOffset = 0;
            if (offsetTop(container) !== void 0) {
              containerTopOffset = offsetTop(container);
            }
            elementBottom = offsetTop(elem) - containerTopOffset + height(elem);
          }
          if (useDocumentBottom) {
            elementBottom = height((elem[0].ownerDocument || elem[0].document).documentElement);
          }
          remaining = elementBottom - containerBottom;
          shouldScroll = remaining <= height(container) * scrollDistance + 1;
          if (shouldScroll) {
            checkWhenEnabled = true;
            if (scrollEnabled) {
              if (scope.$$phase || $rootScope.$$phase) {
                return scope.infiniteScroll();
              } else {
                return scope.$apply(scope.infiniteScroll);
              }
            }
          } else {
            if (checkInterval) {
              $interval.cancel(checkInterval);
            }
            return checkWhenEnabled = false;
          }
        };
        throttle = function(func, wait) {
          var later, previous, timeout;
          timeout = null;
          previous = 0;
          later = function() {
            var context;
            previous = new Date().getTime();
            $interval.cancel(timeout);
            timeout = null;
            func.call();
            return context = null;
          };
          return function() {
            var now, remaining;
            now = new Date().getTime();
            remaining = wait - (now - previous);
            if (remaining <= 0) {
              clearTimeout(timeout);
              $interval.cancel(timeout);
              timeout = null;
              previous = now;
              return func.call();
            } else {
              if (!timeout) {
                return timeout = $interval(later, remaining, 1);
              }
            }
          };
        };
        if (THROTTLE_MILLISECONDS != null) {
          handler = throttle(handler, THROTTLE_MILLISECONDS);
        }
        scope.$on('$destroy', function() {
          container.unbind('scroll', handler);
          if (unregisterEventListener != null) {
            unregisterEventListener();
            return unregisterEventListener = null;
          }
        });
        handleInfiniteScrollDistance = function(v) {
          return scrollDistance = parseFloat(v) || 0;
        };
        scope.$watch('infiniteScrollDistance', handleInfiniteScrollDistance);
        handleInfiniteScrollDistance(scope.infiniteScrollDistance);
        handleInfiniteScrollDisabled = function(v) {
          scrollEnabled = !v;
          if (scrollEnabled && checkWhenEnabled) {
            checkWhenEnabled = false;
            return handler();
          }
        };
        scope.$watch('infiniteScrollDisabled', handleInfiniteScrollDisabled);
        handleInfiniteScrollDisabled(scope.infiniteScrollDisabled);
        handleInfiniteScrollUseDocumentBottom = function(v) {
          return useDocumentBottom = v;
        };
        scope.$watch('infiniteScrollUseDocumentBottom', handleInfiniteScrollUseDocumentBottom);
        handleInfiniteScrollUseDocumentBottom(scope.infiniteScrollUseDocumentBottom);
        changeContainer = function(newContainer) {
          if (container != null) {
            container.unbind('scroll', handler);
          }
          container = newContainer;
          if (newContainer != null) {
            return container.bind('scroll', handler);
          }
        };
        changeContainer(windowElement);
        if (scope.infiniteScrollListenForEvent) {
          unregisterEventListener = $rootScope.$on(scope.infiniteScrollListenForEvent, handler);
        }
        handleInfiniteScrollContainer = function(newContainer) {
          if ((newContainer == null) || newContainer.length === 0) {
            return;
          }
          if (newContainer instanceof HTMLElement) {
            newContainer = angular.element(newContainer);
          } else if (typeof newContainer.append === 'function') {
            newContainer = angular.element(newContainer[newContainer.length - 1]);
          } else if (typeof newContainer === 'string') {
            newContainer = angular.element(document.querySelector(newContainer));
          }
          if (newContainer != null) {
            return changeContainer(newContainer);
          } else {
            throw new Exception("invalid infinite-scroll-container attribute.");
          }
        };
        scope.$watch('infiniteScrollContainer', handleInfiniteScrollContainer);
        handleInfiniteScrollContainer(scope.infiniteScrollContainer || []);
        if (attrs.infiniteScrollParent != null) {
          changeContainer(angular.element(elem.parent()));
        }
        if (attrs.infiniteScrollImmediateCheck != null) {
          immediateCheck = scope.$eval(attrs.infiniteScrollImmediateCheck);
        }
        return checkInterval = $interval((function() {
          if (immediateCheck) {
            return handler();
          }
        }), 0);
      }
    };
  }
]);

var mod = angular.module('share.offline_db_util',[]);
mod.factory('share.offline_db_util',
[
    '$q',
    '$rootScope',
    'share_setting',
    'blockUI',
function(
    $q,
    $rootScope,
    share_setting,
    blockUI 
){
    function get(){
       var db_name = share_setting.STORE_DB_PREFIX + share_setting.STORE_ID;
       return new PouchDB(db_name);           
    }
    function remove_doc(doc_id){
        var defer = $q.defer();

        var db = get();
        db.get(doc_id).then(
             function(doc) { 
                db.remove(doc).then(
                    function(response){ 
                        defer.resolve(response); 
                    }
                    ,function(reason){ 
                        defer.reject(reason); 
                    }
                )
            }
            ,function(reason){ defer.reject(reason); }
        );              
        
        return defer.promise;
    }
    function is_exist(){
        var defer = $q.defer();
        var db_name = '_pouch_' + share_setting.STORE_DB_PREFIX + share_setting.STORE_ID;
        var request = indexedDB.open(db_name);

        request.onupgradeneeded = function (e){
            e.target.transaction.abort();
            // defer.resolve(false);
        }
        request.onsuccess = function(e) {
            defer.resolve(true);
        }
        request.onerror = function(e) {
            if(e.target.error.name == "AbortError"){
                indexedDB.deleteDatabase(db_name);
                defer.resolve(false);
            }else{
                defer.reject('error when checking db existance');
            }
        }   
        return defer.promise;
    }  

    function download_product(is_create_if_local_db_not_exist){
        /*
            return {
                local: the_number_of_local_doc
                remote: the_number_of_remote_doc
                docs_written : pouch_response_docs_written
            }
        */
        var defer = $q.defer();

        if(is_create_if_local_db_not_exist){
            _force_download_product().then(
                function(response){
                    defer.resolve(response);
                },function(reason){
                    defer.reject(reason);
                }
            )
        }else{
            is_exist().then(
                function(is_db_exist){
                    if(is_db_exist){
                        _force_download_product().then(
                            function(response){
                                defer.resolve(response);
                            },function(reason){
                                defer.reject(reason);
                            }
                        )
                    }else{
                        defer.resolve(null);
                    }
                },
                function(reason){
                    return defer.reject(reason);
                }
            )
        }
        return defer.promise;
    } 

    function _force_download_product(){
        var defer = $q.defer();

        var store_id = 18;
        var db_name = 'liquor_' + store_id;
        var local_db = new PouchDB(db_name);
        var couch_server_url = 'https://' + 'ffireventaiduretrimarril' + ':' + 'O7bnrIIMumwfueNuMat6SnaA' + '@' + 'khanhlu2013ceci.cloudant.com'
        var source_url = couch_server_url + '/' + db_name;

        // var store_id = share_setting.STORE_ID;
        // var db_name = share_setting.STORE_DB_PREFIX + store_id;
        // var local_db = new PouchDB(db_name);
        // var source_url = share_setting.COUCH_SERVER_URL + '/' + db_name;

        blockUI.start('syncing database ...');
        console.log('begin syncing for store_id: ' + store_id);

        PouchDB.replicate(source_url, local_db/*target*/, {batch_size:200 ,batches_limit:10 })
            .on('change', function (info) {
                $rootScope.$apply(function()  {
                    // var message = 'docs_read: ' + info.docs_read + ', docs_written: ' + info.docs_written + ', doc_write_failures: ' + info.doc_write_failures;
                    var message = info.docs_written + ' products synced';
                    blockUI.message(message);
                });                            
            })
            .on('complete', function (info) {              
                defer.resolve(info);
                blockUI.stop();   
            })
            .on('error', function (err) {
                $rootScope.$apply(function()  {
                    var message = 'there is sync error: ' + err;
                    defer.reject(message);
                    blockUI.stop();
                });                     
            });
        return defer.promise;
    }           

    function get_pouch_view_name(view_name){
        /*
            since couch build all views that are group into one doc (when any of them is query), i 
            want to have each view resign in separate doc so that i can fully LAZY building the view 
            to spread out the work load for smoother user experience. 

            Now, we have multiple doc that each have a separate id and contain 1 view. I also have 
            a convention to name the doc_id as _design/view_name so that the doc id can be calculated
            from the view name. This helper function construct the view name that understood by pouchdb
        */
        return view_name + '/' + view_name;
    }

    return{
        get:get,
        remove_doc : remove_doc,
        is_exist : is_exist,
        download_product : download_product,
        get_pouch_view_name : get_pouch_view_name
    }
}]);











var mod = angular.module('share.validation.number',[]);
mod.directive('validFloat',function(){
    /*
        only model is not null and is not contain white space, this validation directive will kick in 
    */
    return{
        restrict: 'A',
        require: 'ngModel',
        link: function($scope,$element,$attrs,ngModelCtrl){
            
            var validator = function(value,condition){
                /*
                    pre-requisite: value is not null and value is not contain white space only
                */
                value = value.trim();
                if(isNaN(value)){
                    return false;
                }                

                //by now, value is a number. we init a few thing
                var valid = true;
                var value = Number(value);
                var condition = $attrs['validFloat'];
                
                //if there is no extra condition, it is valid
                if(condition === ''){
                    return true;
                }
                
                //check extra condition
                if(condition === 'gt0'){
                    if(value > 0){
                        return true;
                    }else{
                        return false;
                    }
                }else if(condition === 'gte0'){
                    if(value >= 0){
                        return true;
                    }else{
                        return false;
                    }
                }
                else{
                     return false;
                }
            }
            ngModelCtrl.$parsers.unshift(function(value){
                //value comming from the html ui. we are cleaning it up to pass into the controller
                if(value === null/*we never happen. value at most will be empty string*/ || value.trim().length === 0){
                    ngModelCtrl.$setValidity('validFloat',true);
                    return null;//however due to an unknown reason, the null is not return into the model. instead, the model.property will be deleted. we need more investigate
                }else{
                    var valid = validator(value);
                    ngModelCtrl.$setValidity('validFloat',valid);
                    return valid ? Number(value) : undefined;                    
                }
                // var valid = validator(value);
                // ngModelCtrl.$setValidity('validFloat',valid);
                // return valid ? Number(value) : undefined;                      
            });

            ngModelCtrl.$formatters.unshift(function(value){
                //value is comming from the controller, we are formatting it up to pass it into the ui
                if(value === null || value.trim().length === 0){
                    ngModelCtrl.$setValidity('validFloat',true);
                }else{
                    ngModelCtrl.$setValidity('validFloat',validator(value));
                }
                return value  
            })
        }
    }
});
var mod = angular.module('share.directive',[]);


mod.directive('ngEnter', function () {
    //need this to make text box work for enter key
    return function (scope, element, attrs) {
        element.bind("keydown keypress", function (event) {
            if(event.which === 13) {
                scope.$apply(function (){
                    scope.$eval(attrs.ngEnter);
                });
                event.preventDefault();
            }
        });
    };
});

mod.directive('blurMe', ['$timeout','$parse',function($timeout, $parse) {
    return {
        //scope: true,   // optionally create a child scope
        link: function(scope, element, attrs) {
            var model = $parse(attrs.blurMe);
            scope.$watch(model, function(value) {
                if(value === true) { 
                        $timeout(function() {
                        element[0].blur(); 
                    });
                }
            });
            // to address @blesh's comment, set attribute value to 'false'
            // on blur event:
            element.bind('focus', function() {
                if(model.assign !== undefined){
                    model.assign(scope, false);
                    // scope.$apply(model.assign(scope, false));
                }
            });
        }
    };
}]); 

mod.directive('focusMe', ['$timeout','$parse',function($timeout, $parse) {
    return {
        //scope: true,   // optionally create a child scope
        link: function(scope, element, attrs) {
            var model = $parse(attrs.focusMe);
            scope.$watch(model, function(value) {
                if(value === true) { 
                    $timeout(function() {
                        element[0].focus(); 
                        // if(element[0].select !== undefined){
                        //      element[0].select();
                        // }
                    });
                }
            });
            // to address @blesh's comment, set attribute value to 'false'
            // on blur event:
            element.bind('blur', function() {
                if(model.assign !== undefined){
                    scope.$apply(model.assign(scope, false));
                }
            });
        }
    };
}]);  
var mod = angular.module('share.filter', []);

mod.filter('not_show_zero', function () {
    return function(input) {
        if(input === '$0.00'){
            return "";
        }
        else if(input === '0'){
            return "";
        }
        else if(input === 0){
            return "";
        }
        else{
            return input
        }
    };
});    

mod.filter("emptyToEnd", function () {
    return function (array, key) {
        if (!angular.isArray(array)) return;
        var present = array.filter(function (item) {
            if(key.indexOf('()') != -1){
                return item[key.replace('()','')]();
            }else{
                return item[key];    
            }
        });
        var empty = array.filter(function (item) {
            if(key.indexOf('()') != -1){
                return !item[key.replace('()','')]();
            }else{
                return !item[key];    
            }
        });
        return present.concat(empty);
    };
});
var mod = angular.module('share.menu');
mod.requires.push.apply(mod.requires,[
    'share.ui',
    'model.group'
])

mod.controller('share.menu.menuCtrl',
[
    '$scope',
    '$window',
    'share.ui.alert',
    'share.ui.confirm',
    'model.group.manage',
function(
    $scope,
    $window,
    alert_service,
    confirm_service,
    manage_group
){
    $scope.menu_setting_group = function(){
        manage_group();
    }
    $scope.menu_setting_store = function(){
        alert_service('store settings');
    }
    $scope.menu_setting_mix_match = function(){
        alert_service('mix match settings');
    }
    $scope.menu_setting_payment_type = function(){
        alert_service('payment type settings');
    }
    $scope.menu_setting_shortcut = function(){
        alert_service('shortcut');
    }
    $scope.menu_action_logout = function(){
        confirm_service('logout?').then(
            function(){
                $window.location.href = '/account/logout/';
            }
        )
    }
}])

var mod = angular.module('share.ui');

mod.factory('share.ui.alert',['$modal',function($modal){
    return function(alert_obj,title,color){
        if(title === undefined){
            title = 'alert';
        }
        if(color === undefined){
            color = 'red';
        }
        var message;
        if(typeof(alert_obj) === 'string'){
            message = alert_obj;
            if(message === '_cancel_' || message === undefined/*cancel click*/ || message === 'backdrop click' || message === 'escape key press'){
                return;
            }
        }else{
            if(alert_obj.constructor.name === 'PouchError' || alert_obj.constructor.name === 'Error'){
                title = 'Pouch error: ' + alert_obj.name;
                message = alert_obj.message;
            }else{
                if(alert_obj.status === 0){
                    message = 'internet is disconnected!'
                }else{
                    title = 'please report ajax bug:'
                    message = 'url: ' + alert_obj.config.url;
                }                    
            }
        }

        var warning_class = ""
        if(color == 'green'){
            warning_class = 'alert alert-success'
        }else if(color == 'blue'){
            warning_class = 'alert alert-info'
        }else if(color == 'orange'){
            warning_class = 'alert alert-warning'
        }else if(color == 'red'){
            warning_class = 'alert alert-danger'
        }

        var template = 
        '<form name="form" novalidate>' +
            '<div id="service/ui/alert/dialog" class="modal-header ' + warning_class + '">' +
                '<h3 class="modal-title">' + title + '</h3>' +
            '</div>' +
            '<div class="modal-body">' +
                '<h1 id="service/ui/alert/message_lbl">' + message + '</h1>' +
            '</div>' +
            '<div class="modal-footer">' +
                '<button id="service/ui/alert/ok_btn" type="submit" class="btn btn-success" ng-click="ok()">ok</button>' +
            '</div>' +
        '</form>'
        ;


        var ModalCtrl = function($scope,$modalInstance){
            $scope.ok = function(){
                $modalInstance.close();
            }
        }
        ModalCtrl.$inject = ['$scope','$modalInstance'];
        var dlg = $modal.open({
            template : template,
            controller : ModalCtrl,
            size : 'md'
        });         
    }
}]);
var mod = angular.module('share.ui');

mod.factory('share.ui.confirm',['$modal',function($modal){
    return function(message,type){
        if(type == null){
            type = 'warning';
        }
        var warning_class = 'alert alert-' + type;
        
        var template = 
            '<div id="service/ui/confirm/dialog" class="modal-header ' + warning_class + '">' +
                '<h3 class="modal-title">confirm</h3>' +
            '</div>' +
            '<div class="modal-body">' +
                '<h1 id="service/ui/confirm/message_txt">' + message + '</h1>' +
            '</div>' +
            '<div class="modal-footer">' +
                '<button id="service/ui/confirm/cancel_btn" class="btn btn-warning" ng-click="cancel()" type="button">cancel</button>' +                
                '<button id="service/ui/confirm/ok_btn" type="submit" class="btn btn-success" ng-click="ok()">ok</button>' +
            '</div>'
        ;

        var ModalCtrl = function($scope,$modalInstance){
            $scope.ok = function(){
                $modalInstance.close();
            }
            $scope.cancel = function(){
                $modalInstance.dismiss('_cancel_');
            }               
        }
        ModalCtrl.$inject = ['$scope','$modalInstance'];
        var dlg = $modal.open({
            template : template,
            controller : ModalCtrl,
            size : 'md'
        });         
        return dlg.result;
    }
}]);

angular.module('share.util.csrf',[]).config(['$httpProvider',function($httpProvider) {
    //boilerplate code to make angularjs to work with django in ajax term
    $httpProvider.defaults.xsrfCookieName = 'csrftoken';
    $httpProvider.defaults.xsrfHeaderName = 'X-CSRFToken';           
    $httpProvider.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8';

    $httpProvider.defaults.withCredentials = true;

    var param = function(obj) {
        var query = '', name, value, fullSubName, subName, subValue, innerObj, i;
          
        for(name in obj) {
            value = obj[name];
            
            if(value instanceof Array) {
                for(i=0; i<value.length; ++i) {
                    subValue = value[i];
                    fullSubName = name + '[' + i + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += param(innerObj) + '&';
                }
            }
            else if(value instanceof Object) {
                for(subName in value) {
                    subValue = value[subName];
                    fullSubName = name + '[' + subName + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += param(innerObj) + '&';
                }
            }
            else if(value !== undefined && value !== null)
                query += encodeURIComponent(name) + '=' + encodeURIComponent(value) + '&';
        }
        return query.length ? query.substr(0, query.length - 1) : query;
    };
    // Override $http service's default transformRequest
    $httpProvider.defaults.transformRequest = [function(data) {
        return angular.isObject(data) && String(data) !== '[object File]' ? param(data) : data;
    }];
}]);
var mod = angular.module('share.util');

mod.factory('share.util.misc',function(){
    function get_unique_lst(lst) {
        //i assume this would be based on javascript identity operator: ==
        return lst.reduce(function(p, c) {
            if (p.indexOf(c) < 0) p.push(c);
            return p;
        }, []);
    };    

    function get_item_from_lst_base_on_id(id,lst){
        var item = null;
        for(var i = 0;i<lst.length;i++){
            if(lst[i].id == id){
                item = lst[i];
                break;
            }
        }
        return item;
    }
    return{
        get_unique_lst:get_unique_lst,
        get_item_from_lst_base_on_id:get_item_from_lst_base_on_id
    }
});
var mod = angular.module('share.util');
mod.factory('share.util.number',function(){
    function round_float_2_decimal(num){
        return parseFloat(num.toFixed(2));
    }
    function round_float_1_decimal(num){
        return parseFloat(num.toFixed(1));
    }      

    return{
        round_float_1_decimal:round_float_1_decimal,
        round_float_2_decimal:round_float_2_decimal
    }    
});
var mod = angular.module('model.group');
mod.requires.push.apply(mod.requires,[
    'model.store_product'
])
 
mod.factory('model.group.Group',
[
    '$injector',
function(
    $injector
){
    function Group(id,name,sp_lst){
        this.id = id;
        this.name = name;
        this.sp_lst = sp_lst;
    }
    Group.build = function(data){
        var sp_lst = null;
        var Store_product = $injector.get('model.store_product.Store_product');
        if(data.sp_lst != undefined){
            sp_lst = data.sp_lst.map(Store_product.build)
        }
        return new Group(data.id,data.name,sp_lst);
    }
    return Group;
}]);

var mod = angular.module('model.group');
mod.factory('model.group.create',
[
    '$q',
    'model.group.prompt',
    'model.group.rest',
function(
    $q,
    prompt_service,
    rest    
){
    return function(){
        var defer = $q.defer();

        prompt_service(null).then(
             function(group_prompt_result){ 
                rest.create_item(group_prompt_result).then(
                    function(created_group){
                        defer.resolve(created_group);
                    },function(reason){
                        defer.reject(reason);
                    }
                )
            }
            ,function(reason){
                defer.reject(reason);
            }
        );
        
        return defer.promise;
    }
}]);
var mod = angular.module('model.group');
mod.factory('model.group.edit',
[
    '$http',
    '$q',
    'model.group.prompt',
    'model.group.rest',
function(
    $http,
    $q,
    group_prompt,
    rest_service
){
    return function(original_group){
        var defer = $q.defer();

        rest_service.get_item(original_group.id)
        .then(
            function(group){ 
                return group_prompt(group); 
            }
            ,function(reason){
                defer.reject(reason); 
            }
        )
        .then(
            function(prompt_data){
                rest_service.edit_item(prompt_data,original_group.id)
                .then(
                    function(group){
                        defer.resolve(group);
                    }
                    ,function(reason){
                        defer.reject(reason);
                    }
                )
            },
            function(reason){
                defer.reject(reason);
            }
        );

        return defer.promise;
    }
}]);

var mod = angular.module('model.group');
mod.requires.push.apply(mod.requires,[
    'share.ui'
])

mod.factory('model.group.manage',
[
    '$modal',
    '$templateCache',
    'model.group.rest',
function
(
    $modal,
    $templateCache,
    rest_service
){
    return function(){
        var dlg = $modal.open({
            template:$templateCache.get('model.group.manage.html'),
            controller:'model.group.manage.modalCtrl',
            size:'lg',
            resolve:{
                group_lst: function(){
                    return rest_service.get_lst();
                }
            }
        });
        return dlg.result;
    }
}]);

mod.controller('model.group.manage.modalCtrl',
[
    '$scope',
    '$modalInstance',
    '$rootScope',
    'share.ui.confirm',    
    'share.ui.alert',    
    'model.group.execute',
    'model.group.edit',
    'model.group.create',  
    'model.group.rest',      
    'group_lst',   
function(
    $scope,
    $modalInstance,
    $rootScope,
    confirm_service,
    alert_service,
    exe_service,
    edit_service,
    create_service,
    rest_service,
    group_lst
){
    $scope.group_lst = group_lst;

    $scope.execute_group = function(group_id){
        exe_service(group_id);
    }
    $scope.delete_group = function(group){
        confirm_service('delete ' + group.name + ' group?').then(
            function(data){
                if(data === false){
                    return;
                }
                rest_service.delete_item(group.id)
                .then(
                    function(){
                        var index = null;
                        for(var i = 0;i<$scope.group_lst.length;i++){
                            if($scope.group_lst[i].id === group.id){
                                index = i;
                                break;
                            }
                        }
                        if(index === null){
                            alert_service('Bug: should be unreachable. can not find deleted index after success response');
                        }else{
                            $scope.group_lst.splice(i,1);
                        }
                    },
                    function(reason){
                        alert_service(reason);
                    }
                )                            
            }
        )
    }
    $scope.add_group = function(){
        create_service().then(
            function(group){
                $scope.group_lst.push(group);
            },function(reason){
                alert_service(reason);
            }   
        )
    }
    $scope.edit_group = function(group){
        edit_service(group).then(
            function(data){
                angular.copy(data,group);
            },
            function(reason){
                alert_service(reason);
            }
        )                
    }
    $scope.exit = function(){
        $rootScope.$emit('model.group.manage',$scope.group_lst)
        $modalInstance.close();
    }
}])
var mod = angular.module('model.group');
mod.requires.push.apply(mod.requires,[
    'share.ui',
    'share.util',
    'model.store_product'
])
mod.factory('model.group.prompt',
[
    '$modal',
    '$templateCache',
    'share.ui.alert',
    'share.util.misc',
    'model.store_product.search.online.multiple',
function(
    $modal,
    $templateCache,
    alert_service,
    misc_util,
    search_sp_online_multiple_service
){
    return function(original_group){
        var ModalCtrl = function($scope,$modalInstance,original_group){
            if(original_group == null){
                original_group = {sp_lst:[]};
            }
            $scope.original_group = original_group;
            $scope.group = angular.copy($scope.original_group);

            $scope.remove_sp = function(sp){
                for(var i = 0;i<$scope.group.sp_lst.length;i++){
                    if(sp.id == $scope.group.sp_lst[i].id){
                        $scope.group.sp_lst.splice(i,1);
                        break;
                    }
                }
            }

            $scope.add_sp = function(){
                search_sp_online_multiple_service().then(
                    function(sp_lst){
                        for(var i = 0;i<sp_lst.length;i++){
                            if(misc_util.get_item_from_lst_base_on_id(sp_lst[i].id,$scope.group.sp_lst) == null){
                                $scope.group.sp_lst.push(sp_lst[i]);
                            }
                        }
                    },
                    function(reason){
                        alert_service(reason);
                    }
                )

            }
            $scope.is_unchange = function(){
                return angular.equals($scope.group,$scope.original_group);
            }
            $scope.reset = function(){
                $scope.group = angular.copy($scope.original_group);
            }
            $scope.ok = function(){
                $modalInstance.close($scope.group);
            }
            $scope.cancel = function(){
                $modalInstance.dismiss('_cancel_');
            }
        }
        ModalCtrl.$inject = ['$scope','$modalInstance','original_group'];
        var dlg = $modal.open({
            template:$templateCache.get('model.group.prompt.html'),
            controller:ModalCtrl,
            size:'md',
            backdrop:'static',
            resolve:{
                original_group:function(){return original_group}
            }
        })

        return dlg.result;
    }
}]);
var mod = angular.module('model.group');
mod.factory('model.group.rest',
[
    '$http',
    '$q',
    'model.group.Group',
function(
    $http,
    $q,
    Group
){
    function get_item(group_id){
        var defer = $q.defer();

        $http({
            url:'/group/get_item',
            method:'GET',
            params:{group_id:group_id}
        }).then(
            function(data){
                defer.resolve(Group.build(data.data));
            },function(reason){
                defer.reject(reason);
            }
        )
        return defer.promise;
    }
    function edit_item(prompt_data,group_id){
        var defer = $q.defer();
        $http({
            url:'/group/update_angular',
            method:'POST',
            data:{group:JSON.stringify(prompt_data),id:group_id}
        })
        .then(
            function(data){
                defer.resolve(Group.build(data.data));
            }
            ,function(reason){ 
                defer.reject(reason);
            }
        )
        return defer.promise;
    }
    function get_lst(){
        /*
            data return is a group but not containing breakdown product for speed reason
        */
        var defer = $q.defer();
        $http({
            url:'/group/get_lst',
            method:'GET',
        }).then(
            function(data){
                defer.resolve(data.data.map(Group.build));
            },function(reason){
                defer.reject(reason);
            }
        )
        return defer.promise;
    }
    function create_item(group_prompt_result){
        var defer = $q.defer();
        $http({
            url:'/group/insert_angular',
            method:'POST',
            data:{group:JSON.stringify(group_prompt_result)}
        }).then(
            function(data){
                defer.resolve(Group.build(data.data));
            },
            function(reason){
                return $q.reject(reason);
            }
        );
        return defer.promise;
    }
    function delete_item(group_id){
        var defer = $q.defer();
        get_item(group_id).then(
            function(group){
                if(group.sp_lst.length === 0){
                    $http({
                        url:'/group/delete_angular',
                        method:'POST',
                        data:{group_id:group_id}
                    }).then(
                        function(){
                            defer.resolve();
                        },
                        function(reason){
                            defer.reject(reason);
                        }
                    );
                }else{
                    defer.reject('group must be empty to be deleted');
                }
            }
            ,function(reason){
                defer.reject(reason);
            }
        )
        return defer.promise;
    }        
    function execute_item(group_id,option){
        var defer = $q.defer();

        $http({
             method:'POST'
            ,url:'/group/execute'
            ,data:{group_id:group_id,option:JSON.stringify(option)}
        }).then(
            function(group_response_data){
                defer.resolve(Group.build(group_response_data.data));
            }
            ,function(reason){
                defer.reject(reason);
            }
        )       
        return defer.promise; 
    }

    return{
        delete_item:delete_item,
        create_item:create_item,
        get_lst:get_lst,
        get_item:get_item,
        edit_item:edit_item,
        execute_item:execute_item
    }
}])






var mod = angular.module('model.mix_match');
mod.requires.push.apply(mod.requires,[
    'model.store_product'
])

mod.factory('model.mix_match.Mix_match',
[
    'model.store_product.Store_product'
,function(
    Store_product
){
    function Mix_match(id,name,mm_price,is_include_crv_tax,qty,sp_lst,is_disable){
        this.id = id;
        this.name = name;
        this.mm_price = mm_price;
        this.is_include_crv_tax = is_include_crv_tax
        this.qty = qty;
        this.sp_lst = sp_lst;
        this.is_disable = is_disable;
    }
    Mix_match.build = function(raw_json){
        return new Mix_match(
             raw_json.id
            ,raw_json.name
            ,parseFloat(raw_json.mm_price)
            ,raw_json.is_include_crv_tax
            ,raw_json.qty
            ,raw_json.sp_lst.map(Store_product.build)//sp_lst
            ,raw_json.is_disable
        )
    }
    return Mix_match;
}])
var mod = angular.module('model.non_inventory');

mod.factory('model.non_inventory.Non_inventory',[function(){
    //CONSTRUCTOR
    function Non_inventory(
         name
        ,price
        ,is_taxable
        ,crv
        ,cost
    ){
        this.name = name;
        this.price = price;
        this.is_taxable = is_taxable;
        this.crv = crv;
        this.cost = cost;
    }
    Non_inventory.prototype = {
         constructor : Non_inventory
        ,get_b4_tax_price : function(){
            var result =  this.price + this.crv;
            return result;
        }
        ,get_product_tax : function(tax_rate){
            var result = 0.0;
            if(this.is_taxable){
                result = this.get_b4_tax_price() * tax_rate / 100.0
            }
            return result;
        }
        ,get_otd_price : function(tax_rate){
            return this.get_b4_tax_price() + this.get_product_tax(tax_rate);
        }
    }        

    return Non_inventory;
}]);  
var mod = angular.module('model.product')

mod.factory('model.product.Prod_sku_assoc',[function(){
    function Prod_sku_assoc(product_id,creator_id,store_lst,sku_str){
        this.product_id = product_id;
        this.creator_id = creator_id;
        this.store_lst = store_lst;
        this.sku_str = sku_str;
    }
    Prod_sku_assoc.build = function(raw_json){
        return new Prod_sku_assoc(
             raw_json.product_id
            ,raw_json.creator_id
            ,raw_json.store_set
            ,raw_json.sku_str
        );
    }
    return Prod_sku_assoc;
}]);
var mod = angular.module('model.product');

mod.requires.push.apply(mod.requires,[
    'share.util'
]);

mod.factory('model.product.Product',[
    '$injector',
    'model.product.Prod_sku_assoc',
    'share.util.number',
    'share.util.misc',
function(
    $injector,
    Prod_sku_assoc,
    number_util,
    misc_util
){
    function Product(product_id,name,sp_lst,prod_sku_assoc_lst){
        this.product_id = product_id;
        this.name = name;
        this.sp_lst = sp_lst;
        this.prod_sku_assoc_lst = prod_sku_assoc_lst;
    }

    Product.prototype = {
         constructor : Product
        ,get_sp_lst : function(sku){
            if(sku === null || sku === undefined){
                return this.sp_lst
            }else{
                var temp_lst = this.prod_sku_assoc_lst.filter(function(item){
                    return item.sku_str === sku;
                });
                if(temp_lst.length === 0){
                    return [];
                }else if(temp_lst.length !== 1){
                    throw Exception('Bug: product model is corrupted.');
                }else{
                    var prod_sku_assoc = temp_lst[0];
                    var store_lst = prod_sku_assoc.store_lst;
                    var result = [];
                    for(var i = 0;i<this.sp_lst.length;i++){
                        var cur_sp = this.sp_lst[i];
                        if(_is_sp_in_store_lst(cur_sp,store_lst)){
                            result.push(cur_sp);
                        }
                    }
                    return result;
                }
            }
        }
        ,get_suggest_main : function(field){
            /*
                price and cost: we use median, and median does not have percent. so main suggest is a single value without associate percent
                name,crv,taxable: we use mode, and mode does have percent. so main suggest is a dictionary with value and percent.
            */
            if(field === 'price' || field === 'cost'){
                return _get_median(this._get_suggest_raw_detail(field));
            }else{
                var lst = this._get_mode_statistic(field);
                if(lst.length !== 0){
                    return lst[0];
                }else{
                    return null;
                }            
            }
        }
        ,get_suggest_extra : function(field){
            if(field === 'price' || field === 'cost'){
                return _unique_and_compress(this._get_suggest_raw_detail(field));
            }else{
                return this._get_mode_statistic(field);
            }
        }
        ,_get_mode_statistic : function(field){
            if(field === 'price' || field ==='cost'){
                return null;//we don't calculate mode for these 2 field
            }

            var lst = this._get_suggest_raw_detail(field);
            var stat_lst = [];
            for(var i = 0;i<lst.length;i++){
                var key = lst[i];
                var stat_item = _get__keyCountPercent__item_in_lst_base_on_key(key,stat_lst);
                if(stat_item === null){
                    stat_item = {value:key,count:1,percent:null}
                    stat_lst.push(stat_item);
                }else{
                    stat_item.count += 1;
                }
            }
            //calculate sum
            var sum = 0;
            for(var i = 0;i<stat_lst.length;i++){
                sum += stat_lst[i].count;
            }

            //calculate percent
            for(var i = 0;i<stat_lst.length;i++){
                stat_lst[i].percent = Math.round(stat_lst[i].count / sum * 100);
            }   
            return stat_lst.sort(function(a,b){
                return b.count - a.count; 
            });        
        }
        ,_get_suggest_raw_detail : function(field){
            var lst = [];
            var sp_lst = this.sp_lst;
            for(var i = 0;i<sp_lst.length;i++){
                     if(field == 'price')       {if(sp_lst[i].price!=null)      {lst.push(sp_lst[i].price);}}
                else if(field == 'cost')        {if(sp_lst[i].get_cost()!=null) {lst.push(sp_lst[i].get_cost());}}
                else if(field == 'crv')         {if(sp_lst[i].get_crv()!=null)  {lst.push(sp_lst[i].get_crv());}}
                else if(field == 'name')                                        {lst.push(sp_lst[i].name);}
                else if(field == 'is_taxable')                                  {lst.push(sp_lst[i].is_taxable);}                    
                else                                                            {return null;}
            }
            return lst;
        }
    }
    function _get__keyCountPercent__item_in_lst_base_on_key(key,lst){
        var result = null;
        for(var i = 0;i<lst.length;i++){
            if(lst[i].value === key){
                result = lst[i];
                break;
            }
        }
        return result;
    }
    function _is_sp_in_store_lst(sp,store_lst){
        var result = false;
        for(var i =0;i<store_lst.length;i++){
            if(sp.store_id === store_lst[i]){
                result = true;
                break;
            }
        }
        return result;
    }
    function _unique_and_compress(lst){
        var unique_lst = misc_util.get_unique_lst(lst);
        return unique_lst;
    }
    function _get_median(values) {
        if(values.length == 0){
            return null;
        }

        values.sort( function(a,b) {return b - a;} );
        var half = Math.floor(values.length/2); 
        if (values.length % 2) { 
            return values[half]; 
        }else { 

            return number_util.round_float_2_decimal((values[half-1] + values[half]) / 2.0); 
        }
    } 
    Product.build = function(raw_json){
        Store_product = $injector.get('model.store_product.Store_product');
        var sp_lst = null;
        if(raw_json.store_product_set != undefined){
            sp_lst = raw_json.store_product_set.map(Store_product.build);
        }

        //build prod_sku_assoc
        var prod_sku_assoc_lst = null;
        if(raw_json.prodskuassoc_set!=undefined){
            prod_sku_assoc_lst = raw_json.prodskuassoc_set.map(Prod_sku_assoc.build);
        }

        //actual build
        return new Product(
             raw_json.product_id
            ,raw_json.name
            ,sp_lst
            ,prod_sku_assoc_lst
        )
    }
    return Product;    
}]);
var mod = angular.module('model.receipt');
mod.requires.push.apply(mod.requires,[
    'share.offline_db_util'
])
mod.factory('model.receipt.dao',
[
    '$q',
    'model.receipt.storage_adapter',
    'share_setting',
    'blockUI',
    'share.offline_db_util',
function(
    $q,
    receipt_storage_adapter,
    share_setting,
    blockUI,
    offline_db_util
){
    function get_receipt_lst(){
        blockUI.start('getting offline receipt ...');
        var defer = $q.defer();

        offline_db_util.is_exist().then(
            function(is_exist){
                if(!is_exist){
                    defer.resolve(null);
                    blockUI.stop();
                }else{
                    var db = offline_db_util.get();
                    var view_name = offline_db_util.get_pouch_view_name(share_setting.VIEW_BY_D_TYPE);
                    db.query(view_name,{key:share_setting.RECEIPT_DOCUMENT_TYPE})
                    .then(
                        function(pouch_result){
                            var result = [];
                            for(var i = 0;i<pouch_result.rows.length;i++){
                                result.push(pouch_result.rows[i].value);
                            }
                            defer.resolve(result.map(function(x){return receipt_storage_adapter.pouch_2_javascript(x)}));
                            blockUI.stop();
                        }
                        ,function(reason){
                            defer.reject('Bug: get offline receipt has error');
                            blockUI.stop();
                        }
                    );                        
                }
            },
            function(reason){
                defer.reject(reason);
                blockUI.stop();
            }
        )
        return defer.promise;
    }

    function get_item(receipt_doc_id){
        blockUI.start('getting offline receipt ...');
        var defer = $q.defer();

        offline_db_util.is_exist().then(
            function(is_exist){
                if(!is_exist){
                    defer.resolve(null);
                    blockUI.stop();
                }else{
                    var db = offline_db_util.get();
                    db.get(receipt_doc_id).then(
                        function(pouch_result){
                            defer.resolve(receipt_storage_adapter.pouch_2_javascript(pouch_result));
                            blockUI.stop();
                        }
                        ,function(reason){
                            defer.reject(reason);
                            blockUI.stop();
                        }
                    );
                }
            },
            function(reason){
                defer.reject(reason);
                blockUI.stop();
            }
        )
        return defer.promise;            
    }

    function adjust_receipt_tender(receipt,tender_ln_lst){
        var defer = $q.defer();
        receipt.tender_ln_lst = tender_ln_lst;
        var db = offline_db_util.get();
        db.put(receipt_storage_adapter.javascript_2_pouch(receipt),receipt.doc_id,receipt.doc_rev).then(
            function(response){
                get_item(response.id).then(
                    function(update_receipt){
                        defer.resolve(receipt);
                    },function(reason){
                        defer.reject(reason);
                    }
                )
            },function(reason){
                defer.reject(reason);
            }
        )
        return defer.promise;
    }

    return{
         get_receipt_lst : get_receipt_lst
        ,get_item:get_item
        ,adjust_receipt_tender:adjust_receipt_tender
    }    
}])

/*
    NOTE: It is the responsibility of push_receipt module to donwload product ONLY IF there is product_offline. We can find out
            if a donwload product operation is taking place by looking into push_receipt_module_response.offline_product_count. 
            WHY do we need to see if donwload product operation is taking place? to optimize operation that need to push receipt then 
            download product NO_MATTER_WHAT such as: init_db in sale app, and sync operation in sale_app


    The response of this module:
    {
        . receipt_count
        . offline_product_count
    }
*/

var mod = angular.module('model.receipt');
mod.requires.push.apply(mod.requires,[
    'share.offline_db_util'
])
mod.factory('model.receipt.push',
[
    '$http',
    '$q',
    'model.receipt.dao',
    'share.offline_db_util',
    'blockUI',
function(
    $http,
    $q,
    dao,
    offline_db_util,
    blockUI
){

    function _clean_up(receipt_doc_id_lst,sp_doc_id_lst){
        var defer = $q.defer();
        if(receipt_doc_id_lst.length === 0 && sp_doc_id_lst.length === 0){ defer.resolve(true);return defer.promise; }

        var promise_lst = []            
        for(var i = 0;i<receipt_doc_id_lst.length;i++){
            promise_lst.push(offline_db_util.remove_doc(receipt_doc_id_lst[i]));
        }
        for(var i = 0;i<sp_doc_id_lst.length;i++){
            promise_lst.push(offline_db_util.remove_doc(sp_doc_id_lst[i]));
        }
        //this is a good optimized spot to decide if donwload product is need here
        $q.all(promise_lst).then(
            function(){ 
                offline_db_util.download_product(false).then(
                    function(){
                        defer.resolve();
                    }
                    ,function(reason){
                        defer.reject(reason);
                    }
                )
            }
            ,function(reason){ d
                efer.reject(reason);
            }
        )
        return defer.promise;
    }

    return function(){

        blockUI.start('uploading receipts ...')
        var defer = $q.defer();

        dao.get_receipt_lst().then(
            function(receipt_lst){
                if(receipt_lst === null){
                    defer.resolve(null);
                    blockUI.stop();
                }else if(receipt_lst.length === 0){
                    defer.resolve({receipt_count:0,offline_product_count:0}); 
                    blockUI.stop();
                }
                else{
                    $http({
                         method: 'POST'
                        ,url:'/receipt/push'
                        ,data: {receipt_lst: JSON.stringify(receipt_lst)}
                    }).then(
                        function(response){
                            var receipt_doc_id_lst = response.data.receipt_doc_id_lst;
                            var sp_doc_id_lst = response.data.sp_doc_id_lst;
                            _clean_up(receipt_doc_id_lst,sp_doc_id_lst).then(
                                function(){ 
                                    defer.resolve({
                                        receipt_count : receipt_doc_id_lst.length,
                                        offline_product_count : sp_doc_id_lst.length
                                    });
                                    blockUI.stop();
                                }
                                ,function(reason){ 
                                    defer.reject(reason); 
                                    blockUI.stop();
                                }
                            );
                        }
                        ,function(reason){ 
                            defer.reject(reason);
                            blockUI.stop(); 
                        }
                    );                        
                }
            },function(reason){
                defer.reject(reason); 
                blockUI.stop();
            }
        )

        return defer.promise;
    }      

}])
var mod = angular.module('model.receipt');
mod.requires.push.apply(mod.requires,[
    'share.util'
])
mod.factory('model.receipt.storage_adapter',
[
    'share_setting',
    'share.util.misc',
function(
    share_setting,
    misc_service
){
    function _java_2_pouch__receipt_ln(receipt_ln){
        /*  
            desc        : a helper to help converting 
            depromote   : true 
        */
        return receipt_ln;
    }
    function _pouch_2_java__mm_deal_info_stamp(doc){
        var mm_deal_info_stamp = null;
        if(doc!==null){
            mm_deal_info_stamp = new Mix_match_deal_info_stamp(
                 doc.name
                ,doc.unit_discount
            );
        }
        return mm_deal_info_stamp;
    }
    function _pouch_2_java__non_inventory(doc){
        var non_inventory = null;
        if(doc!==null){
            non_inventory = new Non_inventory(
                 doc.name
                ,doc.price
                ,doc.is_taxable
                ,doc.crv
                ,doc.cost                            
            );                
        }
        return non_inventory;
    }
    function _pouch_2_java__store_product_stamp(doc){
        var store_product_stamp = null;
        if(doc!==null){
            store_product_stamp = new Store_product_stamp(
                 doc.sp_id
                ,doc.doc_id
                ,doc.offline_create_sku
                ,doc.name
                ,doc.price
                ,doc.value_customer_price
                ,doc.crv
                ,doc.is_taxable
                ,doc.is_sale_report
                ,doc.p_type
                ,doc.p_tag
                ,doc.cost
                ,doc.vendor
                ,doc.buydown                    
            );
        }
        return store_product_stamp;
    }
    function _pouch_2_java__receipt_ln(doc){
        var receipt_ln = new Receipt_ln(
             doc.id
            ,doc.qty
            ,doc.discount
            ,doc.override_price
            ,null//store_product
            ,_pouch_2_java__store_product_stamp(doc.store_product_stamp)
            ,_pouch_2_java__mm_deal_info_stamp(doc.mm_deal_info_stamp)
            ,_pouch_2_java__non_inventory(doc.non_inventory)
            ,new Date(doc.date)
        );
        return receipt_ln;
    }

    function _pouch_2_java__tender_ln(doc){
        var pt = null;
        if(doc.pt !== null){ 
            pt = misc_service.get_item_from_lst_base_on_id(doc.pt.id,share_setting.PAYMENT_TYPE_LST); 
        }
        
        var tender_ln = new Tender_ln(
            doc.id,
            pt,
            doc.amount,
            doc.name
        );
        return tender_ln;
    }

    function pouch_2_javascript(doc){
        var receipt = new Receipt
        (
             doc.id 
            ,new Date(doc.date)
            ,doc.tax_rate
            ,doc.tender_ln_lst.map(function(x){return _pouch_2_java__tender_ln(x)})
            ,doc.receipt_ln_lst.map(_pouch_2_java__receipt_ln)
            ,doc._id
            ,doc._rev
        );
        return receipt;
    }
    function javascript_2_pouch(receipt){
        /*
            desc    : see comment on top of this file
            param   : receipt: receipt_app/model/Receipt obj
            return  : a document corresponding to this receipt
        */
        var doc = {
             id             : receipt.id
            ,date           : receipt.date.toString()
            ,tax_rate       : receipt.tax_rate
            ,tender_ln_lst  : receipt.tender_ln_lst
            ,receipt_ln_lst : receipt.receipt_ln_lst.map(_java_2_pouch__receipt_ln)
            ,d_type         : share_setting.RECEIPT_DOCUMENT_TYPE
        }
        return doc;
    }

    return {
         javascript_2_pouch:javascript_2_pouch
        ,pouch_2_javascript:pouch_2_javascript
    };    
}])
var mod = angular.module('model.report')
mod.requires.push.apply(mod.requires,[
    'model.store_product'
])

mod.factory('model.report.Report',[
    '$injector',
function(
    $injector
){
    function Report(id,name,sp_lst){
        this.id = id;
        this.name = name;
        this.sp_lst = sp_lst;
    }
    Report.build = function(data){
        var sp_lst = null;
        var Store_product = $injector.get('model.store_product.Store_product');
        if(data.sp_lst != undefined){
            sp_lst = data.sp_lst.map(Store_product.build)
        }
        return new Report(data.id,data.name,sp_lst);
    }
    return Report;
}]);
var mod = angular.module('model.store');

mod.factory('model.store.Store',
[
    //dependency
function(
    //dependency_alias
){
    function Store(id,name,tax_rate,phone,street,city,state,zip_code,is_profit_information_exchange
        ,display_is_report
        ,display_type
        ,display_tag
        ,display_group
        ,display_deal
        ,display_vendor
        ,display_buydown
        ,display_vc_price
        ,display_stock
    ){
        this.id = id;
        this.name = name;
        this.tax_rate = tax_rate
        this.phone = phone;
        this.street = street;
        this.city = city;
        this.state = state;
        this.zip_code = zip_code;
        this.is_profit_information_exchange = is_profit_information_exchange;

        this.display_is_report = display_is_report;
        this.display_type = display_type;
        this.display_tag = display_tag;
        this.display_group = display_group;
        this.display_deal = display_deal;
        this.display_vendor = display_vendor;
        this.display_buydown = display_buydown;
        this.display_vc_price = display_vc_price;
        this.display_stock = display_stock;
    }
    Store.build = function(raw_json){
        return new Store(
             raw_json.id
            ,raw_json.name
            ,parseFloat(raw_json.tax_rate)
            ,raw_json.phone
            ,raw_json.street
            ,raw_json.city
            ,raw_json.state
            ,raw_json.zip_code
            ,raw_json.is_profit_information_exchange

            ,raw_json.display_is_report
            ,raw_json.display_type
            ,raw_json.display_tag
            ,raw_json.display_group
            ,raw_json.display_deal
            ,raw_json.display_vendor
            ,raw_json.display_buydown
            ,raw_json.display_vc_price
            ,raw_json.display_stock                
        )
    }
    return Store;
}]);
var mod = angular.module('model.store_product');
mod.requires.push.apply(mod.requires,[
    'model.product',
    'share.util',
    'share.offline_db_util'
])
mod.factory('model.store_product.dao',
[
    '$q',
    'model.store_product.Store_product',
    'model.store_product.Kit_breakdown_assoc',
    'model.product.Product',
    'model.product.Prod_sku_assoc',
    'share.util.misc',
    'share_setting',
    'blockUI',
    'share.offline_db_util',
function(
    $q,
    Store_product,
    Kit_breakdown_assoc,
    Product,
    Prod_sku_assoc,
    misc_service,
    share_setting,
    blockUI,
    offline_db_util
){
    function _create_sp(sp_couch,sp_lst_of_bd_assoc){
        var prod_sku_assoc_lst = [];
        for(var i = 0;i<sp_couch.sku_lst.length;i++){
            var temp = new Prod_sku_assoc(
                 sp_couch.product_id
                ,null//creator id
                ,[sp_couch.store_id,]//store_lst
                ,sp_couch.sku_lst[i]//sku_str
            );
            prod_sku_assoc_lst.push(temp);
        }
        var product = new Product(
             sp_couch.product_id
            ,null//name
            ,null//sp_lst
            ,prod_sku_assoc_lst
        );
        var breakdown_assoc_lst = [];
        for(var i = 0;i<sp_couch.breakdown_assoc_lst.length;i++){
            var assoc = sp_couch.breakdown_assoc_lst[i];
            var sp = misc_service.get_item_from_lst_base_on_property('product_id'/*property*/,assoc.product_id,sp_lst_of_bd_assoc);
            breakdown_assoc_lst.push(new Kit_breakdown_assoc(null/*id*/,sp/*breakdown*/,assoc.qty))
        }
        var kit_assoc_lst = null;/* Since sp.kit_assoc_lst does not need to collect sale data, i decided not to store this info offline to simplify the project. (this info is needed for client-side validation when updating sp.kit info) In this case, since we instantiate sp from searching from offline db (versus from ajax data), sp does not contain this info. If user decided to edit kit info from this sp instance, we will by pass client-side validation which prevent infinte loop when breakdown contain kit*/
        var sp = new Store_product(
             sp_couch.id
            ,sp_couch.product_id
            ,sp_couch.store_id
            ,sp_couch.name
            ,sp_couch.price
            ,sp_couch.value_customer_price
            ,sp_couch.crv
            ,sp_couch.is_taxable
            ,sp_couch.is_sale_report
            ,sp_couch.p_type
            ,sp_couch.p_tag
            ,sp_couch.cost
            ,sp_couch.vendor
            ,sp_couch.buydown
            ,product
            ,null//group_lst
            ,breakdown_assoc_lst
            ,kit_assoc_lst                           
            ,sp_couch._id
            ,sp_couch._rev
            ,null//cur_stock : we don't store this info in couch/pouch
            ,null//report_lst
        );
        return sp;
    }

    function _post_search_aka_recursive_search_for_bd_and_form_sp(sp_couch){
        var defer = $q.defer();

        if(sp_couch.breakdown_assoc_lst.length === 0){
            defer.resolve(_create_sp(sp_couch,[]/*breakdown assoc lst*/));
        }else{
            var promise_lst = [];
            for(var i = 0;i<sp_couch.breakdown_assoc_lst.length;i++){
                promise_lst.push(by_product_id(sp_couch.breakdown_assoc_lst[i].product_id))
            }
            $q.all(promise_lst).then(
                 function(data){ defer.resolve(_create_sp(sp_couch,data)); }
                ,function(reason){ defer.reject(reason); }
            )
        }
        return defer.promise;
    }

    function by_product_id(product_id){
        blockUI.start('search sp by product_id: ' + product_id);
        var defer = $q.defer();

        var db = offline_db_util.get();
        var view_name = offline_db_util.get_pouch_view_name(share_setting.VIEW_BY_PRODUCT_ID);
        db.query(view_name,{key:product_id}).then(function(lst){
            if(lst.rows.length == 0){ defer.resolve(null); blockUI.stop();}
            else if(lst.rows.length > 1){ defer.reject('multiple product found for 1 product_id ' + product_id); blockUI.stop(); }
            else{
                var sp_couch = lst.rows[0].value;
                _post_search_aka_recursive_search_for_bd_and_form_sp(sp_couch).then(
                     function(sp){ defer.resolve(sp); blockUI.stop(); }
                    ,function(reason){ defer.reject(reason); blockUI.stop(); }
                )

            }
        });
        return defer.promise; 
    }

    function by_sp_doc_id(sp_doc_id){
        blockUI.start('search sp by doc_id: ' + sp_doc_id);
        var defer = $q.defer();
        var db = offline_db_util.get();
        db.get(sp_doc_id).then(
            function(pouch_result){
                _post_search_aka_recursive_search_for_bd_and_form_sp(pouch_result).then(
                     function(sp){ 
                        defer.resolve(sp); 
                        blockUI.stop(); 
                    }
                    ,function(reason){ 
                        defer.reject(reason); 
                        blockUI.stop(); 
                    }
                )                    
            }
            ,function(reason){
                defer.reject('Bug: can not find sp by doc_id in local database. Click void to try again.');
                blockUI.stop();
            }
        );        
        return defer.promise; 
    }

    function by_sku(sku){
        blockUI.start('search for sku: ' + sku )
        var defer = $q.defer();
        var return_lst = [];
        var promise_lst = [];

        var db = offline_db_util.get();
        var view_name = offline_db_util.get_pouch_view_name(share_setting.VIEW_BY_SKU);
        db.query(view_name,{key:sku}).then(function(result){
            for(var i=0;i<result.rows.length;i++){
                var sp_couch = result.rows[i].value;
                promise_lst.push(_post_search_aka_recursive_search_for_bd_and_form_sp(sp_couch));
            }

            $q.all(promise_lst).then(
                function(data){
                    for(var i=0;i<data.length;i++){
                        return_lst.push(data[i]);
                    }
                    defer.resolve(return_lst);
                    blockUI.stop();
                }
                ,function(reason){ defer.reject(reason); blockUI.stop();}
            )   
        });
        return defer.promise;
    }

    return{
         by_sp_doc_id : by_sp_doc_id
        ,by_product_id : by_product_id
        ,by_sku : by_sku
    }    
}]);
var mod = angular.module('model.store_product');
mod.requires.push.apply(mod.requires,
[
    'model.report',
    'model.group',    
    'model.product',
    'share.util'
]);

//Store_product model
mod.factory('model.store_product.Store_product',
[
     '$injector'
    ,'share.util.number'
,function(
     $injector
    ,number_util
){

    //CONSTRUCTOR
    function Store_product(
        id,
        product_id,
        store_id,
        name,
        price,
        value_customer_price,
        crv,
        is_taxable,
        is_sale_report,
        p_type,
        p_tag,
        cost,
        vendor,
        buydown,
        product,
        group_lst,
        breakdown_assoc_lst,
        kit_assoc_lst,
        sp_doc_id,
        sp_doc_rev,
        cur_stock,
        report_lst
    ){
        this.id = id;
        this.product_id = product_id;
        this.store_id = store_id;
        this.name = name;
        this.price = str_2_float(price);
        this.value_customer_price = str_2_float(value_customer_price);
        this.crv = str_2_float(crv);
        this.is_taxable = is_taxable;
        this.is_sale_report = is_sale_report;
        this.p_type = p_type;
        this.p_tag = p_tag;
        this.cost = str_2_float(cost);
        this.vendor = vendor;
        this.buydown = str_2_float(buydown);
        this.product = product;
        this.group_lst = group_lst;
        this.breakdown_assoc_lst = breakdown_assoc_lst;
        this.kit_assoc_lst = kit_assoc_lst;
        this.sp_doc_id = sp_doc_id;
        this.sp_doc_rev = sp_doc_rev;
        this.cur_stock = cur_stock;
        this.report_lst = report_lst;
    }

    //PULIC METHOD
    Store_product.prototype = {
         constructor : Store_product
        ,get_offline_create_sku : function(){
            if(this.is_create_offline){ return this.product.prod_sku_assoc_lst[0].sku_str }
            else return null;
        }
        ,is_instantiate_offline : function(){
            return this.get_rev() !== null;
        }
        ,get_rev : function(){
            return this.sp_doc_rev;
        }
        ,is_create_offline : function(){
            return this.product_id === null;
        } 
        ,is_kit : function(){
            if(this.breakdown_assoc_lst === null || this.breakdown_assoc_lst === undefined){
                return false;
            }else{
                return this.breakdown_assoc_lst.length !=0;    
            }
        }
        ,get_crv : function(){
            return compute_recursive_field(this,'crv');
        }
        ,get_cost : function(){
            return compute_recursive_field(this,'cost');       
        }
        ,get_buydown : function(){
            return compute_recursive_field(this,'buydown');              
        }    
        ,get_my_sku_assoc_lst : function(){
            var result = [];
            for(var i = 0;i<this.product.prod_sku_assoc_lst.length;i++){
                var cur_assoc = this.product.prod_sku_assoc_lst[i];
                var index = cur_assoc.store_lst.indexOf(this.store_id);
                if(index != -1){
                    result.push(cur_assoc);
                }
            }   
            return result;                         
        },
        get_ancestor_lst: function(){
            /*
                this method get all direct and in-direct(grand-farther, great-grand-father ... ) ancestors of this sp. 
            */
            if(this.kit_assoc_lst.length === 0){ return []; }
            else{
                var result = [];
                for(var i = 0;i<this.kit_assoc_lst.length;i++){
                    var cur_kit = this.kit_assoc_lst[i];
                    var cur_ancestor_lst = cur_kit.get_ancestor_lst();//ancester lst of current kit in this sp
                    for(var j=0;j<cur_ancestor_lst.length;j++){
                        if(get_item_in_lst_base_on_id(cur_ancestor_lst[j].id,result) == null){
                            result.push(cur_ancestor_lst[j]);
                        }
                    }
                }
                return result;
            }
        },
        get_decendent_lst: function(){
            if(this.breakdown_assoc_lst.length == 0){
                return [];
            }else{
                var result = [];
                for(var i = 0;i<this.breakdown_assoc_lst.length;i++){
                    var cur_breakdown = this.breakdown_assoc_lst[i].breakdown;
                    var cur_decendent_lst = cur_breakdown.get_decendent_lst();

                    //add itself
                    if(get_item_in_lst_base_on_id(cur_breakdown.id,result) == null){
                        result.push(cur_breakdown);
                    }                        
                    //add decendent
                    for(var j=0;j<cur_decendent_lst.length;j++){
                        if(get_item_in_lst_base_on_id(cur_decendent_lst[j].breakdown.id,result) == null){
                            result.push(cur_decendent_lst[j].breakdown);
                        }
                    }
                }
                return result;
            }                
        },
        is_breakdown_can_be_add: function(sp){
            //down lst
            var down_lst = sp.get_decendent_lst();
            down_lst.push(sp);

            //up lst
            var up_lst = this.get_ancestor_lst();
            up_lst.push(this);

            //verify that down_lst and up_lst is not intesec
            for(var i = 0;i<down_lst.length;i++){
                var cur = down_lst[i];
                if(get_item_in_lst_base_on_id(cur.id,up_lst)!=null){
                    return false;
                }
            }
            return true;
        },
        _get_b4_tax_price:function(){
            return this.price + this.get_crv() - this.get_buydown();
        },
        get_markup:function(){
            var cost = this.get_cost();
            if(cost === null || cost === undefined){
                return null;
            }else{
                var crv = this.get_crv();
                if(crv === null || crv === undefined){
                    crv = 0.0;
                }
                var markup = (this._get_b4_tax_price() - cost - crv) * 100 / cost;
                return number_util.round_float_1_decimal(markup);                    
            }
        },
        get_group_count:function(){
            return this.group_lst.length;
        },            
        get_profit:function(){
            /*this method should not be here, it is a quick fix to get sorting going on in network info. this method only work when this model is attach with a property 'sale'*/
            if(this.sale === undefined){
                return undefined
            }else{
                return this.sale * (this._get_b4_tax_price() - this.get_cost())
            }
        }            
    }

    //PRIVATE METHOD
    function get_item_in_lst_base_on_id(id,lst){
        var result = null;
        for(var i = 0;i<lst.length;i++){
            if(lst[i].id == id){
                result = lst[i];
                break;
            }
        }
        return result;
    }
    function str_2_float(str){
        if(str == null){
            return null;
        }else{
            return parseFloat(str);
        }
    }       
    function compute_recursive_field(sp,field){
        /*
            DESC    :helper filter to recursively calculate kit related field: 
            PRE     :only call this method on kit related field: CRV, BUYDOWN,COST
            RETURN  
                    .if it is a kit: recursively calculate the field
                    .if it is not a kit: return sp.field

        */
        // we should only use this method for 3 fields only: crv,buydow,cost. RETURN NULL IF SP IS NOT A KIT
        
        //CHECK NULL (when create new, sp is null)
        if(sp === null || sp === undefined){
            return undefined;
        }

        //NOT A KIT
        if(!sp.is_kit()){
            return sp[field];
        }

        //A KIT
        var result = 0.0;
        for(var i = 0;i<sp.breakdown_assoc_lst.length;i++){
            var assoc = sp.breakdown_assoc_lst[i];
            result += (compute_recursive_field(assoc.breakdown,field) * assoc.qty);
        }
        result = parseFloat(result.toFixed(2));
        return result;
    }    

    //BUILD METHOD
    function _build(raw_json){

        //build report
        var report_lst = [];
        if(raw_json.report_lst != undefined){
            var Report = $injector.get('model.report.Report');
            report_lst = raw_json.report_lst.map(Report.build)
        }

        //build group
        var group_lst = [];
        if(raw_json.group_lst != undefined){
            var Group = $injector.get('model.group.Group');
            group_lst = raw_json.group_lst.map(Group.build)
        }

        //build product
        var product = null;
        if(raw_json.product != undefined){
            var Product = $injector.get('model.product.Product');
            product = Product.build(raw_json.product);
        }

        //build breakdown assoc list
        var breakdown_assoc_lst = [];
        if(raw_json.breakdown_assoc_lst != undefined && raw_json.breakdown_assoc_lst.length!=0){
            var Kit_breakdown_assoc = $injector.get('model.store_product.Kit_breakdown_assoc')
            breakdown_assoc_lst = raw_json.breakdown_assoc_lst.map(Kit_breakdown_assoc.build)
        }

        //build kit assoc list
        var kit_assoc_lst = [];
        if(raw_json.kit_assoc_lst != undefined && raw_json.breakdown_assoc_lst.length != 0){
            kit_assoc_lst = raw_json.kit_assoc_lst.map(_build);
        }

        return new Store_product(
             raw_json.id
            ,raw_json.product_id
            ,raw_json.store_id
            ,raw_json.name
            ,raw_json.price
            ,raw_json.value_customer_price
            ,raw_json.crv
            ,raw_json.is_taxable
            ,raw_json.is_sale_report
            ,raw_json.p_type
            ,raw_json.p_tag
            ,raw_json.cost
            ,raw_json.vendor
            ,raw_json.buydown
            ,product
            ,group_lst
            ,breakdown_assoc_lst
            ,kit_assoc_lst
            ,null//sp_doc_id - this field is only concern when build sp from offline db
            ,null//sp_doc_rev - this field is only concern when build sp from offline db
            ,raw_json.cur_stock
            ,report_lst
        );
    }             
    Store_product.build = _build;
    return Store_product;
}]);

mod.factory('model.store_product.Kit_breakdown_assoc',
[
    '$injector'
,function(
    $injector
){
    function Kit_breakdown_assoc(id,breakdown,qty){
        this.id = id;
        this.breakdown = breakdown;
        this.qty = qty;
    }
    Kit_breakdown_assoc.build = function(raw_json){
        var Store_product = $injector.get('model.store_product.Store_product')
        var breakdown = Store_product.build(raw_json.breakdown);

        return new Kit_breakdown_assoc(
            raw_json.id,
            breakdown,
            raw_json.qty
        );
    }
    return Kit_breakdown_assoc;
}]);
var mod = angular.module('model.store_product');
mod.requires.push.apply(mod.requires,[
    'share.ui',
    'share.validation.number',
]);

mod.factory('model.store_product.prompt',
[
    '$modal',
    '$http',
    '$q',
    'model.store_product.search.online.single',
    'model.store_product.Store_product',
    'share.ui.alert',
    'model.store_product.type_tag_util',
function(
    $modal,
    $http,
    $q,
    search_single_sp_dlg,
    Store_product,
    alert_service,
    type_tag_util
){
    //- NAME -------------------------------------------------------------------------------------------------------------------------------------------------------
    var template_name_main_suggestion = 
        '<button' + 
            ' id="sp_app/service/prompt/suggest/main/name"' +
            ' ng-click="sp.name=get_suggest_main(\'name\').value"' +
            ' type="button"' +
            ' class="btn btn-primary">' +
                '{{get_suggest_main(\'name\').value}}' +
        '</button>'
    ;
    var template_name_extra_suggestion =
        '<button ' +
            ' id="sp_app/service/prompt/suggest/extra/name"' +
            ' ng-disabled="!is_many_suggestion(\'name\')"' +
            ' type="button"' +
            ' class="btn btn-primary dropdown-toggle">' + 
                '<span class="caret"></span>' +
        '</button type="button">' +
        '<ul class="dropdown-menu" role="menu">' +
            '<li ng-repeat="extra in get_suggest_extra(\'name\')|orderBy:\'percent\':true"><a ng-click="sp.name=extra.value" href="#">{{extra.value}} - ({{extra.percent}}%)</a></li>' +
        '</ul>'      
    ;
    var template_name_suggestion = 
        '<div ng-hide="is_no_suggestion(\'name\')" class="btn-group" dropdown>' +
            template_name_main_suggestion +
            template_name_extra_suggestion +
        '</div>'
    ;
    var template_name = 
        '<div class="form-group">' +
            '<label class="col-sm-4 control-label" >Name:</label>' +
            '<div class="col-sm-8">' +
                '<input id="sp_app/service/prompt/name_txt" name="product_name" ng-model="sp.name" type="text" size="45" required>' +
                template_name_suggestion +
                '<label class="error" ng-show="form.product_name.$error.required">require</label>' +
            '</div>' +
        '</div>' 
    ;

    //- PRICE -------------------------------------------------------------------------------------------------------------------------------------------------------
    var template_price_main_suggestion = 
        '<button' + 
            ' id="sp_app/service/prompt/suggest/main/price"' +
            ' ng-click="sp.price=get_suggest_main(\'price\')"' +
            ' type="button"' +
            ' class="btn btn-primary">' + 

                '{{get_suggest_main(\'price\')|currency}}' + 
        '</button>'
    ;
    var template_price_extra_suggestion = 
        '<button' +
            ' id="sp_app/service/prompt/suggest/extra/price"' +
            ' ng-disabled="!is_many_suggestion(\'price\')"' +
            ' type="button"' +
            ' class="btn btn-primary dropdown-toggle">' + 
                '<span class="caret"></span>' +
        '</button>' +
        '<ul class="dropdown-menu" role="menu">' +
            '<li ng-repeat="extra in get_suggest_extra(\'price\')|orderBy:\'valueOf()\'"><a ng-click="sp.price=extra" href="#">{{extra|currency}}</a></li>' +
        '</ul>'
    ;  
    var template_price_suggestion = 
        '<div ng-hide="is_no_suggestion(\'price\')" class="btn-group" dropdown>' +   
            template_price_main_suggestion +
            template_price_extra_suggestion +
        '</div>'
    ;
    var template_price =
        '<div class="form-group">' +
            '<label class="col-sm-4 control-label">Price:</label>' +
            '<div class="col-sm-8">' +
                '<input id="sp_app/service/prompt/price_txt" name="price" ng-model="sp.price" valid-float="gt0" required>' +
                template_price_suggestion +
                '<label class="error" ng-show="form.price.$error.required">require</label>' +
                '<label class="error" ng-show="form.price.$error.validFloat">invalid</label>' +
            '</div>' +
        '</div>'
    ;

    //- CRV -------------------------------------------------------------------------------------------------------------------------------------------------------
    var template_crv_main_suggestion = 
        '<button' +
            ' id="sp_app/service/prompt/suggest/main/crv"' +
            ' ng-click="sp.crv=get_suggest_main(\'crv\').value"' +
            ' type="button"' +
            ' class="btn btn-primary">' +
                '{{get_suggest_main(\'crv\').value|currency}}' +
        '</button>'         
    ;
    var template_crv_extra_suggestion = 
        '<button' +
            ' id="sp_app/service/prompt/suggest/extra/crv"' +
            ' ng-disabled="!is_many_suggestion(\'crv\')"' +
            ' type="button"' +
            ' class="btn btn-primary dropdown-toggle">' +
                '<span class="caret"></span>' + 
        '</button>' +
        '<ul class="dropdown-menu" role="menu">' +
            '<li ng-repeat="extra in get_suggest_extra(\'crv\')|orderBy:\'percent\':true"><a ng-click="sp.crv=extra.value" href="#">{{extra.value|currency}} - ({{extra.percent}}%)</a></li>' +
        '</ul>'
    ;
    var template_crv_suggestion = 
        '<div ng-hide="is_no_suggestion(\'crv\')" class="btn-group" dropdown>' +
            template_crv_main_suggestion +
            template_crv_extra_suggestion +
        '</div>'
    ;      
    var template_crv = 
        '<div class="form-group">' +
            '<label class="col-sm-4 control-label">Crv:</label>' +
            '<div class="col-sm-8">' +
                '<input id="sp_app/service/prompt/crv_txt" name="crv" ng-model="sp.crv" ng-disabled="{{sp.is_kit()}}" valid-float="gte0" >' +
                template_crv_suggestion +
                '<label class="error" ng-show="form.crv.$invalid">' +
                    'invalid' +
                '</label>' +                                                            
            '</div>' +
        '</div>'
    ;

    //- TAX -------------------------------------------------------------------------------------------------------------------------------------------------------
    var template_taxable_main_suggestion =
        '<button' +
            ' id="sp_app/service/prompt/suggest/main/is_taxable"' +
            ' ng-click="sp.is_taxable=get_suggest_main(\'is_taxable\').value"' +
            ' type="button"' +
            ' class="glyphicon btn btn-primary"' +                
            ' ng-class="get_suggest_main(\'is_taxable\').value ? \'glyphicon-check\' : \'glyphicon-unchecked\'">' +
                '<span>({{get_suggest_main(\'is_taxable\').percent}}%)</span>' +
        '</button>'         
    ;
    var template_taxable_extra_suggestion =
        '<button' +
            ' id="sp_app/service/prompt/suggest/extra/is_taxable"' +
            ' ng-click="sp.is_taxable=!get_suggest_main(\'is_taxable\').value"' +
            ' type="button"' +
            ' class="glyphicon btn btn-primary"' +                
            ' ng-class="!get_suggest_main(\'is_taxable\').value ? \'glyphicon-check\' : \'glyphicon-unchecked\'">' +
                '<span>({{100 - get_suggest_main(\'is_taxable\').percent}}%)</span>' +
        '</button>'    
    ;
    var template_taxable_suggestion = 
        '<div ng-hide="is_no_suggestion(\'is_taxable\')" class="btn-group" dropdown>' +
            template_taxable_main_suggestion +
            template_taxable_extra_suggestion +
        '</div>'
    ;             
    var template_taxable = 
        '<div class="form-group">' +
            '<label class="col-sm-4 control-label">Taxable:</label>' +
            '<div class="col-sm-8">' +
                '<input id="sp_app/service/prompt/is_taxable_check" ng-model="sp.is_taxable" type="checkbox">' +
                template_taxable_suggestion +
            '</div>' +
        '</div>'
    ;        
    //- COST -------------------------------------------------------------------------------------------------------------------------------------------------------
    var template_cost_main_suggestion = 
        '<button' +
            ' id="sp_app/service/prompt/suggest/main/cost"' +
            ' ng-click="sp.cost=get_suggest_main(\'cost\')"' +
            ' type="button"' +
            ' class="btn btn-primary">' +
                '{{get_suggest_main(\'cost\')|currency}}' + 
        '</button>' 
    ;
    var template_cost_extra_suggestion =
        '<button' +
            ' id="sp_app/service/prompt/suggest/extra/cost"' +
            ' ng-disabled="!is_many_suggestion(\'cost\')"' +
            ' type="button"' +
            ' class="btn btn-primary dropdown-toggle">' +
                '<span class="caret"></span>' +
        '</button>' +
        '<ul class="dropdown-menu" role="menu">' +
            '<li ng-repeat="extra in get_suggest_extra(\'cost\')|orderBy:\'valueOf()\'"><a ng-click="sp.cost=extra" href="#">{{extra|currency}}</a></li>' +            
                '<a ng-click="sp.cost=sp.cost" href="#">{{sp.cost|currency}}</a>' +
            '</li>' +
        '</ul>'
    ;
    var template_cost_suggestion = 
        '<div ng-hide="is_no_suggestion(\'cost\')" class="btn-group" dropdown>' +
            template_cost_main_suggestion +
            template_cost_extra_suggestion +
        '</div>'
    ;
    var template_cost =
        '<div class="form-group">' +
            '<label class="col-sm-4 control-label">Cost:</label>' +
            '<div class="col-sm-8">' +
                '<input id="sp_app/service/prompt/cost_txt" name="cost" ng-model="sp.cost" ng-disabled="{{sp.is_kit()}}" valid-float="gt0">' +
                '<label ng-show="sp.get_markup()!== null && sp.get_markup()!== NaN"> markup: {{sp.get_markup()}}%</label>' +
                template_cost_suggestion +
                '<label class="error" ng-show="form.cost.$invalid">' +
                    'invalid' +
                '</label>' +
            '</div>' +
        '</div>'
    ;        

    //- EXTRA -------------------------------------------------------------------------------------------------------------------------------------------------------
    var template_sale_report =
        '<div class="form-group">' +
            '<label class="col-sm-4 control-label">Sale report:</label>' +
            '<div class="col-sm-8">' +
                '<input id="sp_app/service/prompt/is_sale_report_check" ng-model="sp.is_sale_report" type="checkbox">' +
            '</div>' +
        '</div>'
    ;

    var template_vendor =
        '<div class="form-group">' +
            '<label class="col-sm-4 control-label">Vendor:</label>' +
            '<div class="col-sm-8">' +
                '<input id="sp_app/service/prompt/vendor_txt" ng-model="sp.vendor" type="text">' +
            '</div>' +    
        '</div>'
    ;

    var template_buydown = 
        '<div class="form-group">' +
            '<label class="col-sm-4 control-label">Buydown:</label>' +
            '<div class="col-sm-8">' +
                '<input id="sp_app/service/prompt/buydown_txt" name="buydown" ng-disabled="{{sp.is_kit()}}" ng-model="sp.buydown" valid-float="gte0"}}">' +    
                '<label class="error" ng-show="form.buydown.$invalid">' +
                    'invalid' +
                '</label>' +                                     
            '</div>' +
        '</div>'
    ;

    var template_value_customer_price =
        '<div class="form-group">' +
            '<label class="col-sm-4 control-label">value customer price:</label>' +
            '<div class="col-sm-8">' +
                '<input id="sp_app/service/prompt/value_customer_price_txt" name="value_customer_price" ng-model="sp.value_customer_price" valid-float="gt0" />' +
                '<label class="error" ng-show="form.value_customer_price.$invalid">' +
                    'invalid' +
                '</label>' +
            '</div>' +
        '</div>' 
    ;

    var template_sku = 
        '<div ng-show="is_create_new_sp()" class="form-group">' +
            '<label class="col-sm-4 control-label">Sku:</label>' +
            '<div class="col-sm-8">' +
                '<input id="sp_app/service/prompt/sku_txt" name="sku" ng-model="sku" ng-disabled="can_not_change_sku()" type="text" ng-required="is_create_new_sp()">' +
                '<label class="error" ng-show="form.sku.$error.required">require</label>' +
            '</div>' +
        '</div>'
    ;

    var template =
        '<div id="sp_app/service/prompt/dialog" class="modal-header">' +
            '<h3 class="modal-title">{{calculate_title()}}</h3>' +
        '</div>' +

        '<div class="modal-body">' +
            '<form name="form" novalidate role="form">' +
                '<div class="form-horizontal" >' +
                    template_name +
                    template_price +
                    template_crv +
                    template_taxable +
                    template_cost +
                    '<hr>' +
                    template_sale_report +
                    '<div ng-include="\'model.store_product.prompt.template_type_tag.html\'"></div>' +
                    template_vendor +
                    template_buydown +
                    template_value_customer_price +
                    template_sku + 
                '</div>' + /* end form horizontal*/
            '</form>' + /* end modal body*/   
        '</div>' +

        '<div class="modal-footer">' +       
            '<button' +
                ' id="sp_app/service/prompt/duplicate_from_btn"' +
                ' class="btn btn-primary btn-float-left"' +
                ' ng-click="duplicate_from()"' +
                ' ng-show="original_sp===null"' +
                ' type="button">duplicate from</button>' +    
            '<button id="sp_app/service/prompt/cancel_btn" class="btn btn-warning" ng-click="cancel()" type="button">cancel</button>' + 
            '<button ng-disabled="is_unchange()" class="btn btn-primary" ng-click="reset()" type="button">reset</button>' +                               
            '<button id="sp_app/service/prompt/ok_btn" ng-disabled="is_unchange()||form.$invalid" class="btn btn-success" ng-click="ok()" type="button">ok</button>' +
        '</div>'
    ;      

    var ModalCtrl = function($scope,$modalInstance,$filter,original_sp,suggest_product,duplicate_sp,original_sku,lookup_type_tag){
        $scope.suggest_product = suggest_product;
        $scope.duplicate_sp = duplicate_sp;
        $scope.original_sku = original_sku;
        $scope.original_sp = original_sp;
        // initial_blank_sp = {is_sale_report:true,is_taxable:false};
        initial_blank_sp = new Store_product();
        initial_blank_sp.is_sale_report = true;
        initial_blank_sp.is_taxable = false;

        //pending data for storing prompt
        $scope.sku = original_sku;            
        $scope.sp = angular.copy(original_sp);
        if($scope.sp == null){
            if($scope.duplicate_sp == null){
                $scope.sp = angular.copy(initial_blank_sp);
            }else{
                $scope.sp = angular.copy($scope.duplicate_sp);
            }
        }

        //init kit value: we need this because what we store inside - lets say sp.crv - could be different that the current calculated sp.get_crv(). Thus, we init sp.kit_field to be the actual currently calculated field sp that it will display correctly 
        if( !angular.equals($scope.sp,initial_blank_sp) && $scope.sp.is_kit()){
            $scope.sp.crv = $scope.sp.get_crv();
            $scope.sp.cost = $scope.sp.get_cost();
            $scope.sp.buydown = $scope.sp.get_buydown();
        }

        //suggestion
        //we saved statistic calculation into a scope so that we dont have infinite digest cycle
        $scope._suggest_main_name = null;
        $scope._suggest_main_crv = null;
        $scope._suggest_main_is_taxable = null;
        $scope._suggest_main_price = null;
        $scope._suggest_main_cost = null;
        $scope._suggest_extra_name = null;
        $scope._suggest_extra_crv = null;
        $scope._suggest_extra_is_taxable = null;
        $scope._suggest_extra_price = null;
        $scope._suggest_extra_cost = null;
        if($scope.suggest_product !== null){
            $scope._suggest_main_name = $scope.suggest_product.get_suggest_main('name');
            $scope._suggest_main_crv = $scope.suggest_product.get_suggest_main('crv');
            $scope._suggest_main_is_taxable = $scope.suggest_product.get_suggest_main('is_taxable');
            $scope._suggest_main_price = $scope.suggest_product.get_suggest_main('price');
            $scope._suggest_main_cost = $scope.suggest_product.get_suggest_main('cost');
            $scope._suggest_extra_name = $scope.suggest_product.get_suggest_extra('name');
            $scope._suggest_extra_crv = $scope.suggest_product.get_suggest_extra('crv');
            $scope._suggest_extra_is_taxable = $scope.suggest_product.get_suggest_extra('is_taxable');
            $scope._suggest_extra_price = $scope.suggest_product.get_suggest_extra('price');
            $scope._suggest_extra_cost = $scope.suggest_product.get_suggest_extra('cost');           
        }
        $scope.lookup_type_tag = lookup_type_tag.filter(function(item){
            return item.p_type != null && item.p_tag != null;
        });
        $scope.lookup_type = function(){
            return type_tag_util.get_type_lst($scope.lookup_type_tag);
        }
        $scope.lookup_tag = function(type){
            return type_tag_util.get_tag_lst($scope.lookup_type_tag,type);
        }
        $scope.update_selected_type_tag = function(){
            if($scope.selected_type_tag != null){
                $scope.sp.p_type = $scope.selected_type_tag.p_type;
                $scope.sp.p_tag = $scope.selected_type_tag.p_tag;
            }else{
                $scope.sp.p_type = null;
                $scope.sp.p_tag = null;      
            }
        }
        $scope.get_suggest_main = function(field){
            if(field === 'name'){
                return $scope._suggest_main_name;
            }else if(field === 'crv'){
                return $scope._suggest_main_crv;
            }else if(field === 'is_taxable'){
                return $scope._suggest_main_is_taxable;
            }else if(field === 'price'){
                return $scope._suggest_main_price;
            }else if(field === 'cost'){
                return $scope._suggest_main_cost;
            }
        }        
        $scope.get_suggest_extra = function(field){
            if(field === 'name'){
                return $scope._suggest_extra_name;
            }else if(field === 'crv'){
                return $scope._suggest_extra_crv;
            }else if(field === 'is_taxable'){
                return $scope._suggest_extra_is_taxable;
            }else if(field === 'price'){
                return $scope._suggest_extra_price;
            }else if(field === 'cost'){
                return $scope._suggest_extra_cost;
            }
        }              
        $scope.is_no_suggestion = function(field){
            return $scope.get_suggest_main(field) === null;
        }
        $scope.is_many_suggestion = function(field){
            if($scope.suggest_product === null){
                return false;
            }
            var lst= $scope.suggest_product.get_suggest_extra(field);
            if(lst == null){
                return false;
            }else{
                return lst.length >1;
            }
        }
        $scope.reset = function(){
            if($scope.original_sp == null){
                if($scope.duplicate_sp == null){
                    $scope.sp = angular.copy(initial_blank_sp);
                }else{
                    $scope.sp = angular.copy($scope.duplicate_sp);
                }
            }else{
                $scope.sp = angular.copy($scope.original_sp);
            }
            
            $scope.sku = angular.copy($scope.original_sku);
        };             
        $scope.is_unchange = function() {
            var is_unchange_sku = angular.equals($scope.original_sku,$scope.sku);
            var is_unchange_sp = undefined;
            if($scope.original_sp == null){
                if($scope.duplicate_sp == null){
                    is_unchange_sp = angular.equals($scope.sp,initial_blank_sp);
                }else{
                    is_unchange_sp = angular.equals($scope.sp,$scope.duplicate_sp);
                }
                
            }else{
                is_unchange_sp = angular.equals($scope.sp,$scope.original_sp);
            }
            return is_unchange_sp && is_unchange_sku;
        };    
        $scope.can_not_change_sku = function(){
            /*
                sku input only visible when we are creating a new sp. there is 2 cases to create a new sp. 
                    when we scan a sku that is not exist    -> can NOT change sku prefill
                    when we duplicate  product              -> no sku prefill and we CAN change sku (negate this: dup_sp == null -> CANT change sku)
            */
            
            return $scope.duplicate_sp==null;
        }
        $scope.is_create_new_sp = function(){
            return $scope.original_sp == null;
        }
        $scope.calculate_title = function(){
            if($scope.suggest_product != null){
                return 'Add: ' + $scope.suggest_product.name;
            }else if($scope.duplicate_sp != null){
                return 'Duplicate: ' + $scope.duplicate_sp.name;
            }else if($scope.original_sp == null){
                return 'Sku not found. Create new product';
            }else{
                return 'Edit: ' + $scope.original_sp.name;
            }
        };
        $scope.duplicate_from = function(){
            search_single_sp_dlg().then(
                function(dup_from_sp){
                    $scope.sp.name = dup_from_sp.name;
                    $scope.sp.price = dup_from_sp.price;
                    $scope.sp.crv = dup_from_sp.crv;//if this is a kit product, you have to setup kit manually
                    $scope.sp.is_taxable = dup_from_sp.is_taxable;
                    $scope.sp.cost = dup_from_sp.cost;
                    $scope.sp.is_sale_report = dup_from_sp.is_sale_report;
                    $scope.sp.p_type = dup_from_sp.p_type;
                    $scope.sp.p_tag = dup_from_sp.p_tag;
                    $scope.sp.vendor = dup_from_sp.vendor;
                    $scope.sp.buydown = dup_from_sp.buydown;
                    $scope.sp.value_customer_price = dup_from_sp.value_customer_price;
                }
                ,function(reason){
                    alert_service(reason);
                }
            )
        }
        $scope.cancel = function(){
            $modalInstance.dismiss('_cancel_');
        };
        $scope.ok = function(){
            $modalInstance.close({sku:$scope.sku,sp:$scope.sp});
        };
    }
    ModalCtrl.$inject = ['$scope','$modalInstance','$filter','original_sp','suggest_product','duplicate_sp','original_sku','lookup_type_tag'];

    return function(original_sp,suggest_product,duplicate_sp,sku,is_internet_disconnected){
        var dlg = $modal.open({
            template: template,
            controller: ModalCtrl,
            backdrop:'static',
            size: 'lg',
            resolve : {
                 original_sp : function(){return original_sp}
                ,suggest_product : function(){return suggest_product}
                ,duplicate_sp : function(){return duplicate_sp}
                ,original_sku : function(){return sku}
                ,lookup_type_tag : function (){
                    var defer = $q.defer();
                    if(is_internet_disconnected){
                        defer.resolve(type_tag_util.get_cache());
                    }else{
                        defer.resolve(type_tag_util.get());
                    }
                    return defer.promise;
                }                    
            }
        });
        return dlg.result;
    }   
}]);
var mod = angular.module('model.store_product');

mod.factory('model.store_product.type_tag_util',
[
    '$rootScope',
    '$q',
    'model.store_product.rest_type_tag',
function(
    $rootScope,
    $q,
    rest_type_tag
){
    var TYPE_TAG_CACHE_LST = undefined;
    var get_tag_lst = function(type_tag_lst,type){
        var result = [];
        for(var i = 0;i<type_tag_lst.length;i++){
            var cur_type_tag = type_tag_lst[i];
            if(cur_type_tag.p_type === type){
                result.push(cur_type_tag.p_tag); 
            }
        }
        return result;
    }    
    var get_type_lst = function(type_tag_lst){
        var result = [];
        for(var i = 0;i<type_tag_lst.length;i++){
            var type_tag = type_tag_lst[i];
            if(result.indexOf(type_tag.p_type) === -1){
                result.push(type_tag.p_type);
            }
        }
        return result;        
    }
    var get_cache = function(){
        return TYPE_TAG_CACHE_LST;
    }
    var get = function(){
        if(TYPE_TAG_CACHE_LST === undefined){
            return rest_type_tag();
        }else{
            return $q.when(TYPE_TAG_CACHE_LST);
        }
    }  
    var _update_lst = function(){
        var type_lst = get_type_lst(TYPE_TAG_CACHE_LST);
        if(type_lst.indexOf(type_tag_obj.p_type) === -1){
            TYPE_TAG_CACHE_LST.push(type_tag_obj);
        }else{
            var tag_lst = get_tag_lst(TYPE_TAG_CACHE_LST,type_tag_obj.p_type);
            if(tag_lst.indexOf(type_tag_obj.p_tag)=== -1){
                TYPE_TAG_CACHE_LST.push(type_tag_obj);
            }
        }        
    }
    $rootScope.$on('type_tag_downloaded_from_server',function(event,type_tag_lst){
        TYPE_TAG_CACHE_LST = type_tag_lst;
    });
    $rootScope.$on('type_tag_uploaded_to_server',function(event,type_tag_obj){
        if(TYPE_TAG_CACHE_LST === undefined){
            return;
        }
        
        var type_lst = get_type_lst(TYPE_TAG_CACHE_LST);
        if(type_lst.indexOf(type_tag_obj.p_type) === -1){
            TYPE_TAG_CACHE_LST.push(type_tag_obj);
        }else{
            var tag_lst = get_tag_lst(TYPE_TAG_CACHE_LST,type_tag_obj.p_type);
            if(tag_lst.indexOf(type_tag_obj.p_tag)=== -1){
                TYPE_TAG_CACHE_LST.push(type_tag_obj);
            }
        }
    });
  
    return{
        get_type_lst : get_type_lst,
        get_tag_lst : get_tag_lst,
        get_cache : get_cache,
        get : get
    }
}])
var mod = angular.module('model.group');
mod.requires.push.apply(mod.requires,[
    'share.ui',
    'share.offline_db_util'
]);

mod.controller('model.group.execute.controller',
[
    '$scope',
    '$modalInstance',
    '$http',
    'share.ui.alert',
    'model.group.Group',
    'model.group.rest',
    'share.offline_db_util',    
    'group',
function(
    $scope,
    $modalInstance,
    $http,
    alert_service,
    Group,
    group_rest,
    offline_db_util,
    group    
){
    $scope.group = group;
    $scope.option = {};

    $scope.checkbox_click = function(field_name){
        var enable_field_name = 'enable_' + field_name;
        var is_enable = $scope[enable_field_name];
        // if(is_enable === undefined){ is_enable = false; }
        // is_enable = !is_enable;//when this click handler is call, this enable field is not yet update. it is only update when this click handler is executed

        if(is_enable === false){
            delete $scope.option[field_name];
        }else{
            //we are enabling, we need to init value
            if(field_name === 'is_taxable' || field_name === 'is_sale_report'){
                $scope.option[field_name] = false;
            }else if(field_name === 'price'){
                //price does not allow null value. we do nothing
            }else{
                $scope.option[field_name] = null;
            }
        }
    }
    $scope.is_option_empty = function(){
        for(key in $scope.option){
            if($scope.option.hasOwnProperty(key)){
                return false;
            }
        }
        return true;
    }
    $scope.ok = function(){
        group_rest.execute_item($scope.group.id,$scope.option).then(
            function(group_response_data){
                offline_db_util.download_product(false/*is_force*/).then(
                    function(){
                        $scope.group = Group.build(group_response_data);
                        alert_service('execute is complete successfully','info','green');
                        $scope.option = {};
                        $scope.enable_price = false;
                        $scope.enable_crv = false;
                        $scope.enable_is_taxable = false;
                        $scope.enable_cost = false;
                        $scope.enable_is_sale_report = false;
                        $scope.enable_p_tag = false;
                        $scope.enable_p_tag = false;
                        $scope.enable_vendor = false;
                        $scope.enable_buydown = false;
                        $scope.enable_value_customer_price = false;
                    }
                    ,function(reason){
                        alert_service(reason);
                    }
                )
            }
            ,function(reason){
                alert_service(reason);
            }
        )
    }
    $scope.exit = function(){ 
        $modalInstance.dismiss('_cancel_');
    }
}]);

var mod = angular.module('model.group');

mod.factory('model.group.execute',
[
    '$modal',
    '$templateCache',
    'model.group.rest',
function(
    $modal,
    $templateCache,
    group_rest
){
    return function(group_id){
        
        var result = $modal.open({
             template:$templateCache.get('model.group.execute.main.html')
            ,controller:'model.group.execute.controller'
            ,size:'lg'
            ,resolve:{
                group : function(){
                    return group_rest.get_item(group_id);
                }
            }
        });
        return result;
    }
}]);

var mod = angular.module('model.product');

mod.controller('model.product.network_product.controller',
[
    '$scope',
    'share_setting',
function(
    $scope,
    share_setting
){
    $scope.share_setting = share_setting;
    function _is_display_sale_data(network_product){
        var result = false;

        if(network_product.get_sp_lst().length!==0){
            result = network_product.get_sp_lst()[0].sale !== undefined;
        }

        return result;
    }

    $scope.init = function(network_product){
        $scope.network_product = network_product;
        $scope.network_product_summary_lbl_class = 'col-xs-4 control-label';
        $scope.network_product_summary_value_class = 'col-xs-8 form-control-static';   
        $scope.suggest_extra_crv = $scope.network_product.get_suggest_extra('crv');
        $scope.suggest_extra_name = $scope.network_product.get_suggest_extra('name');
        $scope.is_sale_data = _is_display_sale_data(network_product);
        
        //SORT
        $scope.cur_sort_column = 'get_cost()';
        $scope.cur_sort_desc = false;
        $scope.column_click = function(column_name){
            if($scope.cur_sort_column == column_name){
                $scope.cur_sort_desc = !$scope.cur_sort_desc;
            }else{
                $scope.cur_sort_column = column_name;
                $scope.cur_sort_desc = false;
            }
        }
        $scope.get_sort_class = function(column_name){
            if(column_name == $scope.cur_sort_column){
                return "glyphicon glyphicon-arrow-" + ($scope.cur_sort_desc ? 'down' : 'up');
            }else{
                return '';
            }
        }             
    }

    $scope.$on('network_product_is_updated',function(event,network_product){
        /*
            there are 2 way network_product_ctrl is used: sp->info->network_info and sku_not_found_handler. In the former case, we dont want to get network_info everytime we are
            viewing sp.info. so we make it lazy with a button to ajax get network product so we need hook to update network product for this controller.
        */        
        $scope.init(network_product);
    })
}]);
var mod = angular.module('model.store_product');

mod.factory('model.store_product.rest_crud',
[
    '$http',
    '$rootScope',
    '$q',
    'model.store_product.Store_product',
function(
    $http,
    $rootScope,
    $q,
    Store_product
){
    var _response = function(response_data,defer){
        var response_sp = Store_product.build(response_data);
        var type_tag_obj = {
            p_type : response_sp.p_type,
            p_tag : response_sp.p_tag
        }
        $rootScope.$emit('type_tag_uploaded_to_server',type_tag_obj)
        defer.resolve(response_sp);
    }

    var insert_new = function(sp,sku){
        var defer = $q.defer();
        $http({
            url:'/sp/insert_new_sp_angular',
            method: 'POST',
            data:{sku_str:sku,sp:JSON.stringify(sp)}
        }).then(
            function(data){ 
                _response(data.data,defer);
            }
            ,function(reason){ 
                if(reason.data !== null && reason.data !== undefined && reason.data.indexOf('duplicate key value violates unique constraint') !== -1 && reason.data.indexOf('Key (name, store_id)=') !== -1){
                    defer.reject(sp.name + ' is existed. Please select another name');
                }else{
                    defer.reject(reason);
                }
            }
        )
        return defer.promise;
    }

    var insert_old = function(product_id,sku,sp){
        var defer = $q.defer();
        $http({
            url:'/sp/sp_insert_old_angular',
            method:'POST',
            data:{product_id:product_id,sku_str:sku,sp:JSON.stringify(sp)}
        }).then(
            function(data){ 
                _response(data.data,defer);
            }
            ,function(reason){ 
                if(reason.data !== null && reason.data !== undefined && reason.data.indexOf('duplicate key value violates unique constraint') !== -1 && reason.data.indexOf('Key (name, store_id)=') !== -1){
                    defer.reject(sp.name + ' is existed. Please select another name');
                }else{
                    defer.reject(reason);
                }
            }
        )
        return defer.promise;
    }

    var update = function(sp){
        var defer = $q.defer();
        $http({
            url:'/sp/update_sp_angular',
            method: 'POST',
            data:{sp:JSON.stringify(sp)}
        }).then(
            function(data){ 
                _response(data.data,defer);
            }
            ,function(reason){ 
                defer.reject(reason);
            }
        )
        return defer.promise;        
    }


    return{
        insert_new : insert_new,
        insert_old : insert_old,
        update : update
    }
}]);
var mod = angular.module('model.store_product');
mod.requires.push.apply(mod.requires,[
    'model.product'
]);

mod.factory('model.store_product.rest_search',
[
    '$q',
    '$http',
    'model.store_product.Store_product',
    'model.product.Product',
function(
    $q,
    $http,
    Store_product,
    Product
){
    function by_id(product_id){
        var defer = $q.defer();
        $http({
            url:'/sp/search_by_product_id',
            method:'GET',
            params:{product_id:product_id}
        }).then(
             function(data){ 
                var sp = Store_product.build(data.data);
                defer.resolve(sp); 
            }
            ,function(reason){ 
                defer.reject(reason); 
            }
        )

        return defer.promise;
    }
    
    function by_name(name_search_str,after){
        var defer = $q.defer();

        name_search_str = name_search_str.trim();
        if(name_search_str.length == 0){
            defer.reject('error: name search is empty');
            return defer.promise;
        }

        var words = name_search_str.split(' ');
        if(words.length > 2){
            defer.reject('error: search 2 words maximum');
            return defer.promise;
        }

        $http({
            url: '/sp/search_by_name_angular',
            method : "GET",
            params: {name_str:name_search_str,after:after}
        })
        .then(
            function(data){
                defer.resolve(data.data.map(Store_product.build));
            },function(reason){
                defer.reject(reason);
            }
        )
        return defer.promise
    }
    
    function by_sku(sku_search_str){
        sku_search_str = sku_search_str.trim();
        if(sku_search_str.length == 0){ return $q.reject('error: sku is empty'); }
        if(sku_search_str.indexOf(' ') >= 0){ return $q.reject('error: sku cannot contain space'); }

        var defer = $q.defer();
        $http({
            url:'/sp/search_by_sku_angular',
            method:'GET',
            params:{sku_str:sku_search_str}
        }).then(
            function(data){
                var result = {
                     prod_store__prod_sku__1_1:data.data.prod_store__prod_sku__1_1.map(Store_product.build)
                    ,prod_store__prod_sku__1_0:data.data.prod_store__prod_sku__1_0.map(Store_product.build)
                    ,prod_store__prod_sku__0_0:data.data.prod_store__prod_sku__0_0.map(Product.build)
                };
                defer.resolve(result);
            },
            function(reason){ 
                defer.reject(reason); 
            }
        )
        return defer.promise;
    }

    function by_name_sku(search_str,after){
        var token_lst = search_str.split(' ');
        if(token_lst.length > 2){
            return $q.reject('2 words search max');
        }

        var defer = $q.defer();
        $http({
            url : '/sp/search_by_name_sku_angular',
            method: 'GET',
            params : {'search_str':search_str,'after':after}
        })
        .then(
            function(data){ 
                defer.resolve(data.data.map(Store_product.build));
            }
            ,function(reason){
                defer.reject(reason);
            }
        )
        return defer.promise;
    }

    return{
        by_id:by_id,
        by_name:by_name,
        by_sku:by_sku,
        by_name_sku:by_name_sku
    }
}]);

var mod = angular.module('model.store_product');

mod.factory('model.store_product.rest_sku',
[
     '$http'
    ,'$q'
    ,'model.store_product.Store_product'
,function(
     $http
    ,$q
    ,Store_product
){
    return{
        add_sku : function(product_id,sku){
            var defer = $q.defer();
            $http({
                url:'/sp/sku_add_angular',
                method:'POST',
                data: {product_id:product_id,sku_str:sku}
            })
            .then(
                function(data){ 
                    defer.resolve(Store_product.build(data.data));
                }
                ,function(reason){
                    defer.reject(reason); 
                }
            )               
            return defer.promise;
        },

        delete_sku : function(product_id,sku){
            var defer = $q.defer();
            $http({
                url:'/sp/sku_assoc_delete_angular',
                method:'POST',
                data:{product_id:product_id,sku_str:sku}
            })
            .then(
                function(data){ 
                    defer.resolve(Store_product.build(data.data));
                }
                ,function(reason){ 
                    defer.reject(reason); 
                }
            )        
            return defer.promise;        
        }
    }
}])

var mod = angular.module('model.store_product');

mod.factory('model.store_product.rest_type_tag',
[
    '$rootScope',
    '$http',
    '$q',
function(
    $rootScope,
    $http,
    $q
){
    return function(){
        var defer = $q.defer();

        $http({
            url:'/sp/get_lookup_type_tag',
            method:'GET'
        }).then(
             function(data){
                $rootScope.$emit('type_tag_downloaded_from_server',data.data);
                defer.resolve(data.data);
            }
            ,function(reason){
                defer.reject(reason);
            }
        )

        return defer.promise;   
    }
}]);

var mod = angular.module('model.store_product');
mod.requires.push.apply(mod.requires,[
    'share.ui',
    'model.product'
]);

mod.factory('model.store_product.sku_not_found_handler',
[
    '$http',
    '$q',
    'model.store_product.sku_not_found_handler.create.new',
    'model.store_product.sku_not_found_handler.create.old',
    'model.store_product.rest_sku',
    'model.store_product.sku_not_found_handler.select_suggestion',
    'share.ui.alert',
    'model.store_product.Store_product',
    'model.product.Product',
function(
    $http,
    $q,
    create_new_sp_service,
    create_old_sp_service,
    rest_sku,
    sku_not_found_handler_select,
    alert_service,
    Store_product,
    Product
){
    return function(product_lst,my_sp_lst,sku){
        var defer = $q.defer();
        sku_not_found_handler_select(product_lst,my_sp_lst,sku).then(
            function(select_option){
                if(select_option === null)
                {
                    create_new_sp_service(sku).then(
                        function(res){
                            defer.resolve(res);
                        },function(reason){
                            defer.reject(reason);
                        }
                    )
                }
                else if(select_option instanceof Store_product)
                {
                    var cur_store_sp = select_option;
                    rest_sku.add_sku(cur_store_sp.product_id,sku).then(
                        function(res){
                            defer.resolve(res);
                        },function(reason){
                            defer.reject(reason);
                        }
                    )
                }
                else if(select_option instanceof Product)
                {
                    var suggest_product = select_option;
                    create_old_sp_service(suggest_product,sku).then(
                        function(res){
                            defer.resolve(res);
                        },function(reason){
                            defer.reject(reason);
                        }
                    )
                }else{
                    alert_service('Bug: Unexpected select option:' + select_option.constructor.name);
                }
            },
            function(reason){
                defer.reject(reason);
            }
        );
        return defer.promise;
    }
}]);
/*
    This helper is there to implement dry for 3 places that need the same code:
        . product_app.html -> name_search -> infinite_scroll
        . sp.search.online.multiple -> name_sku_search -> infinite_scroll
        . sp.search.online.single -> name_sku_search -> infinite_scroll

    PRE
        . the scope param must define infinite_scroll_reach_the_end flag. (so outside of this service can reset it to false)
            We could have define this flag inside this
            util (the same way we did for scope.infinite_scroll_busy flag)but decide not to. WHY? The reason we define scope.infinite_scroll_busy 
            inside this util because this util always unset this flag when it is exit to make busy flag = false. This mean when we call this function again,
            busy flag have a CHANCE to be false and proceed through the function call. For scope.infinite_scroll_reach_the_end, this util may exit and the flag of 
            reach_the_end is true. if we don't unset this somewhere outside this util for this flag(when we search another string), this util will never be able 
            to go through when it is called again.

        . the scope param must define is_blur_infinite_scroll_triggerer_textbox:
            there will be a textbox that when we search and hit enter it will load the result's first page. 
            Notice that this text box is still in focus. When we scroll to the end of the page, infinite-scroll 
            trigger an ajax call to the server which call block-ui to block the page. after the ajax is done, 
            block-ui will refocus the element which is the text box on top of the page that cause scrolling
            to lost the position. For this reason, when we load the first page (this is the code that sit outside infinite-scroll handler) lets blur the focus of this 
            element so when we scroll down to trigger ajax and block-ui, block-ui will not queue restore-focus element
            that will cause scroll position to be lost. 
*/


var mod = angular.module('model.store_product');
mod.requires.push.apply(mod.requires,['share.ui']);

mod.factory('model.store_product.search.online.infinite_scroll_handler',
[
    '$q',
    'model.store_product.rest_search',
function(
    $q,
    sp_rest_search
){
    return function(scope,search_str,is_name_only_or_name_sku,sp_lst){
        if(scope.infinite_scroll_reach_the_end){
            return $q.when();
        }

        if(scope.infinite_scroll_busy === undefined){
            scope.infinite_scroll_busy = false;
        }else if(scope.infinite_scroll_busy === true){
            return $q.when();
        }

        var defer = $q.defer();
        var after = sp_lst.length;
        scope.infinite_scroll_busy = true;
        var search_func;
        if(is_name_only_or_name_sku){
            search_func = sp_rest_search.by_name
        }else{
            search_func = sp_rest_search.by_name_sku
        }
        search_func(search_str,after).then(
            function(data){
                sp_lst.push.apply(sp_lst,data);
                scope.infinite_scroll_reach_the_end = (data.length === 0);
                scope.infinite_scroll_busy = false;
                defer.resolve();
            }
            ,function(reason){ 
                defer.reject(reason);
            }
        )
        return defer.promise;
    }
}]);
var mod = angular.module('model.store_product');

mod.factory('model.store_product.sku_not_found_handler.create.new',
[
     '$http'
    ,'$q'
    ,'model.store_product.prompt'
    ,'model.store_product.rest_crud'
,function(
     $http
    ,$q
    ,prompt_service
    ,sp_crud_api
){
    return function(sku){
        var defer = $q.defer();
        prompt_service(null/*original_sp*/,null/*suggest_product*/,null/*duplicate_sp*/,sku,false/*is_internet_disconnected*/).then(
             function(prompt_data){ 
                sp_crud_api.insert_new(prompt_data.sp,sku).then(
                    function(res){
                        defer.resolve(res);
                    },function(reason){
                        defer.reject(reason);
                    }
                )
            }
            ,function(reason){ 
                defer.reject(reason);
            }
        );
        return defer.promise;
    }
}]);
var mod = angular.module('model.store_product');

mod.factory('model.store_product.sku_not_found_handler.create.old',
[
    '$http',
    '$q',
    'model.store_product.prompt',
    'model.store_product.rest_crud',
function(
    $http,
    $q,
    prompt_service,
    sp_crud_api
){
    return function(suggest_product,sku){
        var defer = $q.defer();
        prompt_service(null/*original_sp*/,suggest_product,null/*duplicate_sp*/,sku,false/*is_internet_disconnected*/).then(
             function(prompt_data){ 
                sp_crud_api.insert_old(suggest_product.product_id,sku,prompt_data.sp).then(
                    function(res){
                        defer.resolve(res);
                    },function(reason){
                        defer.reject(reason);
                    }
                )
            }
            ,function(reason){ 
                defer.reject(reason);
            }
        )
        return defer.promise;
    }
}]);
var mod = angular.module('model.store_product');
mod.factory('model.store_product.sku_not_found_handler.select_suggestion',[
     '$modal'
    ,'$q' 
    ,'model.store_product.sku_not_found_handler.select_suggestion.store_product'
    ,'model.store_product.sku_not_found_handler.select_suggestion.product'    
,function(
     $modal
    ,$q
    ,select_sp
    ,select_product
){
    /*
                                       |
                                       |
                                       V
                <--------------------START----------------------->
                |                      |                         |
                |                      |                         |
                |                      V                         |
                |  |-------------> CREATE_NEW <---------------|  |
                V  |                                          |  V
             ADD_SKU  <-----------------------------------> ADD_PRODUCT
                |                                                |
                |                                                |
                |------------------> CANCEL <--------------------|
                |                                                |
                |                                                |
                V                                                V
            RETURN_SP                                       RETURN PRODUCT

    */
    return function(product_lst,my_sp_lst,sku){
        var defer = $q.defer();

        if(product_lst.length === 0 && my_sp_lst.length === 0){
            defer.resolve(null);
        }else if(my_sp_lst.length !== 0){
            select_sp(product_lst,my_sp_lst,sku).then(
                function(response){
                    defer.resolve(response);
                }
                ,function(reason){
                    defer.reject(reason);
                }
            )
        }else /*if(product_lst.length !== 0) -- this must be the only case left*/{
            select_product(product_lst,my_sp_lst,sku).then(
                function(response){
                    defer.resolve(response);
                }
                ,function(reason){
                    defer.reject(reason);
                }
            )
        }

        return defer.promise;
    }    
}]);
var mod = angular.module('model.store_product');
mod.requires.push.apply(mod.requires,[
    'share.util'
])
mod.controller('model.store_product.search.online.multiple.controller',
[
    '$scope',
    '$modalInstance',
    'model.store_product.rest_search',
    'share.util.misc',    
    'model.store_product.search.online.infinite_scroll_handler',
function(
    $scope,
    $modalInstance,
    rest_search_service,
    misc_util,
    search_online_infinite_scroll_handler    
){
    $scope.message = "";
    $scope.sp_lst = "";
    $scope.result_sp_lst = [];
    $scope.infinite_scroll_reach_the_end = false;
    $scope.is_blur_infinite_scroll_triggerer_textbox = false;
    $scope.search_str = '';

    $scope.ok = function(){
        $modalInstance.close($scope.result_sp_lst)
    }
    $scope.is_sp_selected = function(sp){
        return misc_util.get_item_from_lst_base_on_id(sp.id,$scope.result_sp_lst) !=null;
    }
    $scope.reset = function(){
        $scope.result_sp_lst = [];
    }
    $scope.toggle_select = function(sp){
        if($scope.is_sp_selected(sp)){
            $scope.remove(sp);
        }else{
            $scope.result_sp_lst.push(sp);
        }
    }
    $scope.remove = function(sp){
        var index = null;
        for(var i = 0;i<$scope.result_sp_lst.length;i++){
            if(sp.id == $scope.result_sp_lst[i].id){
                index = i;
                break;
            }
        }
        $scope.result_sp_lst.splice(index,1);
    }
    $scope.search = function(){
        $scope.search_str = $scope.search_str.trim();

        if($scope.search_str.length == 0){
            $scope.sp_lst = [];
            $scope.message = "";
            return;
        }
        var after = 0;
        $scope.infinite_scroll_reach_the_end = false;
        rest_search_service.by_name_sku($scope.search_str,after).then(
            function(result_lst){
                $scope.sp_lst = result_lst;
                if($scope.sp_lst.length == 0){ 
                    $scope.message = "no result for " + "'" + $scope.search_str + "'";
                }else{ 
                    $scope.message = ""; 
                    $scope.is_blur_infinite_scroll_triggerer_textbox = true;
                }
            },function(reason){
                $scope.message = reason; 
            }
        )
    }
    $scope.cancel = function(){
        $modalInstance.dismiss('_cancel_');
    }

    $scope.infinite_scroll_handler = function(){
        if($scope.search_str === ''){
            return;//somehow infinite-scroll-handler is trigger on first load. This is how i ignore falsy infinite-scroll trigger.
        }
        search_online_infinite_scroll_handler($scope,$scope.search_str,false/*is_name_only_or_name_sku*/,$scope.sp_lst);
    }
}])
var mod = angular.module('model.store_product');
mod.factory('model.store_product.search.online.multiple',
[
    '$modal',
    '$templateCache',
function(
    $modal,
    $templateCache
){
    return function(){
        var dlg = $modal.open({
            template:$templateCache.get('model.store_product.search.online.multiple.template.html'),
            controller:'model.store_product.search.online.multiple.controller',
            size:'lg'
        });
        return dlg.result
    }
}]);

var mod = angular.module('model.store_product');
mod.requires.push.apply(mod.requires,[
    'share.ui'
]);
mod.controller('model.store_product.search.online.single.controller',
[
    '$scope',
    '$modalInstance',
    '$http',
    'model.store_product.rest_search',
    'share.ui.alert',    
    'model.store_product.search.online.infinite_scroll_handler',
function(
    $scope,
    $modalInstance,
    $http,
    rest_search_service,
    alert_service,
    search_online_infinite_scroll_handler    
){
    $scope.message = "";
    $scope.sp_lst = "";
    $scope.infinite_scroll_reach_the_end = false;
    $scope.search_str = '';
    $scope.is_blur_infinite_scroll_triggerer_textbox = false;

    $scope.select = function(sp){
        $modalInstance.close(sp);
    }
    $scope.cancel = function(){
        $modalInstance.dismiss('_cancel_');
    }            
    $scope.search = function(search_by){
        $scope.search_str = $scope.search_str.trim();
        
        if($scope.search_str.length === 0){
            $scope.sp_lst = [];
            $scope.message = "";                    
            return;
        }
        var after = 0;
        $scope.infinite_scroll_reach_the_end = false;
        rest_search_service.by_name_sku($scope.search_str,after).then(
            function(result_lst){
                $scope.sp_lst = result_lst;
                if($scope.sp_lst.length == 0){ 
                    $scope.message = "no result for " + "'" + $scope.search_str + "'";
                }else{ 
                    $scope.message = ""; 
                    $scope.is_blur_infinite_scroll_triggerer_textbox = true;
                }
            },function(reason){
                $scope.message = reason; 
            }
        )

    }
    $scope.infinite_scroll_handler = function(){
        if($scope.search_str === ''){
            return;//somehow infinite-scroll-handler is trigger on first load. This is how i ignore falsy infinite-scroll trigger.
        }
        search_online_infinite_scroll_handler($scope,$scope.search_str,false/*is_name_only_or_name_sku*/,$scope.sp_lst);
    }    
}]);
var mod = angular.module('model.store_product');

mod.factory('model.store_product.search.online.single',
[
    '$modal',
    '$templateCache',
function(
    $modal,
    $templateCache
){
    return function(){
        var dlg = $modal.open({
            template:$templateCache.get('model.store_product.search.online.single.template.html'),
            controller:'model.store_product.search.online.single.controller',
            size:'lg',
        });
        return dlg.result
    }
}]); 
var mod = angular.module('model.store_product');

mod.controller('model.store_product.sku_not_found_handler.select_suggestion.product.controller',
[
    '$scope',
    '$modalInstance',
    '$injector',
    'model.store_product.sku_not_found_handler.select_suggestion.product.confirm',
    'product_lst',
    'my_sp_lst',
    'sku',
function(
    $scope,
    $modalInstance,
    $injector,
    select_product_confirmation,
    product_lst,
    my_sp_lst,
    sku  
){
    $scope.product_lst = product_lst;
    $scope.my_sp_lst = my_sp_lst;
    $scope.sku = sku;
    $scope.cancel = function(){
        $modalInstance.dismiss('_cancel_');
    }
    $scope.select_product = function(product){
        select_product_confirmation(product,product_lst,my_sp_lst,sku).then(
            function(response){
                $modalInstance.close(response);
            }
            ,function(reason){
                $modalInstance.dismiss(reason);
            }
        )
    }
    $scope.select_sp = function(){
        var select_sp_service = $injector.get('model.store_product.sku_not_found_handler.select_suggestion.store_product')
        select_sp_service(product_lst,my_sp_lst,sku).then(
            function(response){
                $modalInstance.close(response);
            }
            ,function(reason){
                $modalInstance.dismiss(reason);
            }
        )
    }
    $scope.create_new_product = function(){
        $modalInstance.close(null);
    }
}])
var mod = angular.module('model.store_product');
mod.factory('model.store_product.sku_not_found_handler.select_suggestion.product',[
    '$modal',
    '$templateCache',
function(
    $modal,
    $templateCache
){
    return function(product_lst,my_sp_lst,sku){ 
        var dlg = $modal.open({
             template:$templateCache.get('model.store_product.sku_not_found_handler.select_suggestion.product.template.html')
            ,controller:'model.store_product.sku_not_found_handler.select_suggestion.product.controller'
            ,size:'lg'
            ,backdrop : 'static'
            ,resolve : {
                 product_lst : function(){
                    return product_lst;
                }
                ,my_sp_lst : function(){
                    return my_sp_lst;
                }
                ,sku : function(){
                    return sku;
                }
            }
        })
        return dlg.result;
    }    
}]);  
var mod = angular.module('model.store_product');
mod.controller('model.store_product.sku_not_found_handler.select_suggestion.store_product.controller',
[
    '$scope',
    '$modalInstance',
    '$injector',
    'share.ui.confirm',    
    'product_lst',
    'my_sp_lst',
    'sku',
function(
    $scope,
    $modalInstance,
    $injector,
    confirm_service,
    product_lst,
    my_sp_lst,
    sku
){
    $scope.product_lst = product_lst;
    $scope.my_sp_lst = my_sp_lst;
    $scope.sku = sku;                
    $scope.cancel = function(){
        $modalInstance.dismiss('_cancel_');
    }
    $scope.return_sp = function(sp){
        confirm_service('Confirm: adding ' + sku + ' sku to ' + sp.name + ' ?').then(
            function(){
                $modalInstance.close(sp);
            }
        )
    }
    $scope.select_product = function(){
        var select_product_service = $injector.get('model.store_product.sku_not_found_handler.select_suggestion.product')
        select_product_service(product_lst,my_sp_lst,sku).then(
            function(response){
                $modalInstance.close(response);
            }
            ,function(reason){
                $modalInstance.dismiss(reason);
            }
        )
    }
    $scope.create_new_product = function(){
        $modalInstance.close(null);
    }
}]);
var mod = angular.module('model.store_product');
mod.factory('model.store_product.sku_not_found_handler.select_suggestion.store_product',[
    '$modal',
    '$templateCache',       
function(
    $modal,
    $templateCache
){
    return function(product_lst,my_sp_lst,sku){
        var dlg = $modal.open({
             template:$templateCache.get('model.store_product.sku_not_found_handler.select_suggestion.store_product.template.html')
            ,controller:'model.store_product.sku_not_found_handler.select_suggestion.store_product.controller'
            ,size:'lg'
            ,backdrop : 'static'
            ,resolve : {
                 product_lst : function(){
                    return product_lst;
                }
                ,my_sp_lst : function(){
                    return my_sp_lst;
                }
                ,sku : function(){
                    return sku;
                }
            }
        })
        return dlg.result;
    }    
}]);
var mod = angular.module('model.store_product');

mod.controller('model.store_product.sku_not_found_handler.select_suggestion.product.confirm.controller',
[
    '$scope',
    '$modalInstance',
    '$injector',
    'share_setting',
    'network_product',
    'product_lst',
    'my_sp_lst',
    'sku',
function(
    $scope,
    $modalInstance,
    $injector,
    share_setting,
    network_product,
    product_lst,
    my_sp_lst,
    sku
){
    $scope.network_product = network_product;
    $scope.share_setting = share_setting;
    $scope.cancel = function(){
        $modalInstance.dismiss('_cancel_');
    }
    $scope.return_product = function(){
        $modalInstance.close(network_product);
    }
    $scope.select_product = function(){
        var select_product_service = $injector.get('model.store_product.sku_not_found_handler.select_suggestion.product')
        select_product_service(product_lst,my_sp_lst,sku).then(
            function(response){
                $modalInstance.close(response);
            }
            ,function(reason){
                $modalInstance.dismiss(reason);
            }
        )
    }
}]);
var mod = angular.module('model.store_product');

mod.factory('model.store_product.sku_not_found_handler.select_suggestion.product.confirm',[
    '$modal',
    '$templateCache',
function(
    $modal,
    $templateCache
){
    return function(network_product,product_lst,my_sp_lst,sku){
        var dlg = $modal.open({
             template:$templateCache.get('model.store_product.sku_not_found_handler.select_suggestion.product.confirm.template.html')
            ,controller:'model.store_product.sku_not_found_handler.select_suggestion.product.confirm.controller'
            ,size:'lg'
            ,backdrop : 'static'
            ,resolve : {
                 network_product : function(){
                    return network_product;
                }                    
                ,product_lst : function(){
                    return product_lst;
                }
                ,my_sp_lst : function(){
                    return my_sp_lst;
                }
                ,sku : function(){
                    return sku;
                }
            }
        })
        return dlg.result;
    }
}]);
var mod = angular.module('app.construct_app_setting',[
    'model.mix_match',
    'model.store'
]);
mod.factory('app.construct_app_setting',
[
    'model.mix_match.Mix_match',
    'model.store.Store',    
function(
    Mix_match,
    Store
){
    return function(share_setting){
        /*
            . there are 2 way to get global setting
                . in django html template. in this case, django auto convert json string into json - i believe with the | safe option
                . through ajax. In this case, the response data.data is an object with setting property is of type string(unlike django template)

            . due to the mixmatch mention above, this set service will convert share_setting(which can be get though template or ajax) property into json if it is string
        */
        //django template auto convert json string into json. but when we ajax to get setting, the response data.data is an object with value to key is of type string. so we need to parse here

        if(typeof(share_setting.STORE) === 'string'){
            share_setting.STORE = JSON.parse(share_setting.STORE)
        }            
        if(typeof(share_setting.MIX_MATCH_LST) === 'string'){
            share_setting.MIX_MATCH_LST = JSON.parse(share_setting.MIX_MATCH_LST)
        }
        if(typeof(share_setting.PAYMENT_TYPE_LST) === 'string'){
            share_setting.PAYMENT_TYPE_LST = JSON.parse(share_setting.PAYMENT_TYPE_LST)
        }
        if(typeof(share_setting.SHORTCUT_LST) === 'string'){
            share_setting.SHORTCUT_LST = JSON.parse(share_setting.SHORTCUT_LST)
        }                      

        var result = 
        {
            STORE:                         Store.build(share_setting.STORE),
            STORE_ID :                     share_setting.STORE_ID,
            TAX_RATE :                     share_setting.TAX_RATE,
            COUCH_SERVER_URL:              share_setting.COUCH_SERVER_URL,       
            STORE_DB_PREFIX:               share_setting.STORE_DB_PREFIX,
            MIX_MATCH_LST :                share_setting.MIX_MATCH_LST.map(Mix_match.build),
            PAYMENT_TYPE_LST:              share_setting.PAYMENT_TYPE_LST,
            SHORTCUT_LST:                  share_setting.SHORTCUT_LST,
            SHORTCUT_ROW_COUNT:            share_setting.SHORTCUT_ROW_COUNT,
            SHORTCUT_COLUMN_COUNT:         share_setting.SHORTCUT_COLUMN_COUNT,
            STORE_PRODUCT_DOCUMENT_TYPE:   share_setting.STORE_PRODUCT_DOCUMENT_TYPE,
            RECEIPT_DOCUMENT_TYPE:         share_setting.RECEIPT_DOCUMENT_TYPE,
            STATIC_URL:                    share_setting.STATIC_URL,
            MAX_RECEIPT_SNOOZE_1:          30,
            MAX_RECEIPT_SNOOZE_2:          60,
            MAX_RECEIPT:                   200,
            VIEW_BY_PRODUCT_ID:            share_setting.VIEW_BY_PRODUCT_ID,
            VIEW_BY_SKU:                   share_setting.VIEW_BY_SKU,
            VIEW_BY_D_TYPE:                share_setting.VIEW_BY_D_TYPE,
        }        
        return result;
    }
}])
var mod = angular.module('app.productApp');
mod.requires.push.apply(mod.requires,[
    'ui.bootstrap',
    'infinite-scroll',
    'blockUI',    
    'share.util.csrf',
    'share.filter',
    'share.directive',
    'share.menu',
    'app.productApp.partial'
]);

mod.config(['$sceDelegateProvider',function($sceDelegateProvider) {
    $sceDelegateProvider.resourceUrlWhitelist([
        // Allow same origin resource loads.
        'self',
        // 'http://127.0.0.1:8000/*', //i think i need this when i am dealing with partial? (the network product partial)
        // Allow loading from our assets domain.  Notice the difference between * and **.
        // 'https://liquorkhanhlu2013.s3.amazonaws.com/**'
    ]);
}]);

mod.config(['blockUIConfig',function(blockUIConfig) {
    blockUIConfig.message = 'loading ...';
    blockUIConfig.autoBlock = true;
    blockUIConfig.delay = 0;
}]);
var app = angular.module('app.productApp');
app.requires.push.apply(app.requires,[
    'model.store_product',
    'share.ui',
    'share.offline_db_util'
]);
app.controller('app.productApp.controller',
[
    '$scope',
    '$rootScope',
    '$q',
    '$window',
    'model.store_product.rest_search',
    'share.ui.alert',
    'share.ui.confirm',
    'model.store_product.sku_not_found_handler',
    'share.offline_db_util',
    'model.store_product.search.online.infinite_scroll_handler',
function(
    $scope,
    $rootScope,
    $q,
    $window,
    sp_rest_search,
    alert_service,
    confirm_service,
    sku_not_found_handler,
    offline_db_util,
    search_online_infinite_scroll_handler
){
    var un_subscribe_group = $rootScope.$on('model.group.manage',function(event,data){
        _refresh_current_sp_lst();
    })
    $scope.$on('$destroy',un_subscribe_group);

    function launch_pos_url(){
        $window.open('sale/index_angular/');
    }
    $scope.launch_pos = function(){
        offline_db_util.is_exist().then(
             function(db_exitance){
                if(db_exitance){
                    confirm_service('launch sale app?').then(function(){
                        launch_pos_url();
                    });                        
                }else{
                    confirm_service('first time download database. continue?').then(function(){
                        launch_pos_url();
                    });
                }
            }
            ,function(reason){
                alert_service(reason)
            }
        )
    }

    $scope.sku_search = function(){
        $scope.name_search_str = "";
        $scope.local_filter = "";
        $scope.sku_search_str = $scope.sku_search_str.trim().toLowerCase();

        if($scope.sku_search_str.length === 0){
            $scope.sp_lst = [];
            return;
        }
        sp_rest_search.by_sku($scope.sku_search_str).then(
            function(data){
                $scope.sp_lst = data.prod_store__prod_sku__1_1;
                if($scope.sp_lst.length === 0){
                    var promise = sku_not_found_handler(data.prod_store__prod_sku__0_0,data.prod_store__prod_sku__1_0,$scope.sku_search_str).then
                    (
                        function(created_sp){ 
                            $scope.sp_lst = [created_sp];
                        }
                        ,function(reason){
                            alert_service(reason);
                        }
                    );
                } 
            }
            ,function(reason){ 
                alert_service(reason);
            }
        )
    }
    function _refresh_current_sp_lst(){
        $scope.sp_lst = [];        
        $scope.name_search_str = '';
        $scope.sku_search_str = '';             
    }    
    $scope.column_click = function(column_name){
        if($scope.cur_sort_column === column_name){
            $scope.cur_sort_desc = !$scope.cur_sort_desc;
        }else{
            $scope.cur_sort_column = column_name;
            $scope.cur_sort_desc = false;
        }
    }
    $scope.get_sort_class = function(column_name){
        if(column_name === $scope.cur_sort_column){
            return "glyphicon glyphicon-arrow-" + ($scope.cur_sort_desc ? 'down' : 'up');
        }else{
            return '';
        }
    }    

    $scope.name_search = function(){
        //clear out search form
        $scope.sku_search_str = "";
        $scope.local_filter = "";
        $scope.infinite_scroll_reach_the_end = false;
        $scope.name_search_str = $scope.name_search_str.trim();
        $scope.sp_lst = [];

        if($scope.name_search_str.length === 0){
            return;
        }
 
        sp_rest_search.by_name($scope.name_search_str,0/*after*/).then(
            function(data){
                $scope.sp_lst = data;

                if(data.length === 0){
                    alert_service('no result found for ' + '"' + $scope.name_search_str + '"','info','blue');
                }else{
                    $scope.is_blur_infinite_scroll_triggerer_textbox = true;
                }
                
            }
            ,function(reason){ 
                alert_service(reason); 
            }
        )
    }

    $scope.infinite_scroll_handler = function(){
        if($scope.name_search_str.length === 0){
            //infinite scroll only apply for name search. because sku search does not have 'after' limit. Thus, when name_serch_str is empty, infinite_scroll_handler will do nothing
            return;
        }
        search_online_infinite_scroll_handler($scope,$scope.name_search_str,true/*is_name_only_or_name_sku*/,$scope.sp_lst);
    }

    //SORT
    $scope.cur_sort_column = 'name';
    $scope.cur_sort_desc = false;        

    $scope.infinite_scroll_reach_the_end = false; //WHY DO WE NEED THIS VAR? read the story inside search_online_infinite_scroll_handler()
    $scope.is_blur_infinite_scroll_triggerer_textbox = false;   

    $scope.sp_lst = [];        
    $scope.name_search_str = '';
    $scope.sku_search_str = '';

}]);
/*
    I could have include this file in the main app file. However, i factor this code out so i can exclude it from karma. WHY? 
    because _GLOBAL_SETTING_ is a constance passing down from the server in the html. This variable is not available in karma
    environment
*/
var mod = angular.module('app.productApp');
mod.requires.push.apply(mod.requires,[
    'app.construct_app_setting'
])

mod.value('share_setting',_GLOBAL_SETTING_);
mod.run(
[
    'app.construct_app_setting',
    'share_setting',
function(
    construct_app_setting,
    share_setting
){
    var constructed_share_setting = construct_app_setting(share_setting);
    for(var k in constructed_share_setting) 
        share_setting[k]=constructed_share_setting[k];
}]);
